In our methodology, we integrated the NTA 8800 standard to determine, simulate, and analyze lighting energy use for both residential and non-residential building types. The objective was to ensure that the calculations and modeling are consistent with the Dutch regulations for assessing building energy performance. NTA 8800, in its various sections, outlines how to handle lighting for residential functions in a simplified manner, as well as how to deal with more detailed calculations for non-residential functions. In the residential case, the standard stipulates that the energy requirement for lighting is set to zero by default if specific calculations or measurements are unavailable. For non-residential cases, there is a structured approach to account for installed power, operating hours, and the parasitic loads associated with lighting systems. This distinction allowed us to build a Python-based pipeline that assigns lighting parameters—such as power density in W/m², parasitic W/m², and burning hours—depending on whether the building is residential or non-residential and on the subcategory under consideration.

In our code, we rely on a set of dictionaries that store both the default ranges for lighting intensities, as well as the operating hours during daytime and nighttime. Specifically, we use formulas consistent with sections 14.2 and 14.3 of NTA 8800, where the total lighting requirement W is segregated into a lighting component WL and a parasitic component WP. For a purely residential zone, the standard states that WL;spec = 0 kWh/m² and WP = 0, effectively ignoring all lighting consumption for residential energy performance calculations. When the building or zone is classified under utility (non-residential) functions, we introduce formulas for installed lighting power Pn and hours of usage tD and tN, the maximum daily and nightly burning hours. The standard, in Table 14.1, provides reference values for tD and tN according to building usage type, such as 2200 hours in the daytime for an office function and 300 hours in the nighttime. We can thereby assign, for example, tD = 2200 and tN = 300 in the simplest scenario, or a small range around these values if we wish to allow some calibration. The lumpsum approach also emerges when the actual installed lighting power is unknown, in which case we use the specific power density Pn;spec multiplied by the floor area of the lighting zone. In the standard, typical lumpsum values appear in Table 14.3, for instance 17 W/m² for an assembly function or 30 W/m² for a retail function.

Furthermore, the standard references the parasitic power consumption of lighting equipment, which includes battery charging for emergency lighting fixtures and stand-by losses for automatic control systems. If one relies on the lumpsum method for parasitic power, the standard gives Wp = (Wpe;spec + Wpc;spec) × Ag,vz, with Wpe;spec and Wpc;spec measured in kWh/m², leading to roughly 2.5 kWh/m²/year. Since there are 8760 hours in a year, one can convert that total energy to a power density of approximately 0.285 W/m². This numeric value aligns well with the approach we implemented in our Python code, where 0.285 W/m² is used as the default for parasitic lighting power density in many non-residential scenarios.

Our workflow encompasses several Python scripts to operationalize these concepts. First, we have a Python module called assign_lighting_values.py, which reads in building attributes such as building_id, building_function, or sub-type. It consults a dictionary named lighting_lookup, in which the user or the code author has pre-filled default W/m² ranges for specific sub-types (for example, 15.0 to 17.0 W/m² for an office) and the associated parasitic range (for instance, 0.28 to 0.30 W/m²). Additionally, the dictionary provides tD_range and tN_range so that we can pick final numeric values based on a strategy, such as the midpoint or a random selection. If desired, overrides can be applied to these defaults by specifying a user_config override table that sets custom min and max values for a particular building_id, building_type, or age range. This is consistent with NTA 8800, which allows for custom or measured values in more advanced audits or measurement-based calibrations.

Having assigned these parameters, we then turn to the lighting.py module, which, after retrieving lights_wm2 and parasitic_wm2, creates the necessary objects in an EnergyPlus input data file (IDF). Our approach populates LIGHTS objects in each thermal zone, setting Design_Level_Calculation_Method to "Watts/Area" and assigning Watts_per_Zone_Floor_Area = lights_wm2. For parasitic power, we create ELECTRICEQUIPMENT objects, again in each zone, with the same "Watts/Area" method but using parasitic_wm2. Each of these objects in the IDF references schedules that detail how lighting usage changes by hour and day of the week. Originally, we had a simpler day/night approach, but we expanded it to incorporate a multi-block schedule that distinguishes weekdays from weekends and sets fractional usage across the day. This approach mimics how NTA 8800 envisions that some building types may have peak occupancy in the morning or mid-day and different partial load in the early evening, followed by security lighting later at night.

We also recognize that in many real-world applications, a building’s lighting usage does not align perfectly with the maximum tD or tN set by NTA 8800. Indeed, the standard acknowledges that these values are maximum burning hours and that more refined presence factors or lighting control factors can be used if evidence or measurements are available. Formulas such as W_{L,j} = (P_{n,j} × FC_j) × (t_D × Fo_{D,j} × FD_j + t_N × Fo_{N,j}) / 1000, which appear in NTA 8800, demonstrate how the total yearly lighting requirement for a given zone j is the product of the installed power, the replacement value compensation factor FC_j, and the sum of day and night hours scaled by occupancy Fo and daylight FD factors. In practice, implementing these multiple factors precisely requires a deeper adaptation of the EnergyPlus schedules, presence-based control logic, and possibly advanced daylighting objects. However, in our code, we confine ourselves to storing the lumpsum or approximate approach, letting the user refine presence or daylight factors as needed in subsequent steps or through specialized schedule creation.

During calibration stages, some or all of these parameters might be locked to single fixed values rather than wide ranges. We reflect this in our dictionary by specifying a post_calibration key, with entries such as (17.0, 17.0) for lights_wm2. This ensures that the user cannot deviate from the measured or audited level. Such an approach is aligned with NTA 8800’s allowance for measured data in custom calculations, where performing on-site measurements or advanced data logging can enable a more accurate final energy assessment. If the user has real lighting measurements for a building, or if they have performed an in-depth lighting design calculation, that data can override or replace the lumpsum approach altogether.

Overall, the rationale behind these scripts is to marry the structure of the Python-based automation with the official methodology of NTA 8800. By doing so, we reduce guesswork about typical lighting usage, keep consistent numeric references to the standard, and allow for user overrides in more detailed analyses. The result is a reproducible code base where each building’s lighting parameters are chosen systematically from standardized rules, with the possibility of more refined calibrations whenever real data is available. This yields a flexible yet NTA 8800-compliant approach to modeling lighting loads in EnergyPlus.