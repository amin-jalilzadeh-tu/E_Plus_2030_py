Folder: D:\Documents\E_Plus_2030_py\idf_objects\fenez

  File: assign_fenestration_values.py
  --- File Contents Start ---
# fenez/assign_fenestration_values.py

from .materials_config import get_extended_materials_data, compute_wwr

def assign_fenestration_parameters(
    building_row,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config_fenez=None,
    use_computed_wwr=False,
    include_doors_in_wwr=False
):
    """
    Retrieve the final Window-to-Wall Ratio (WWR) for a building, optionally
    computing it from sub-element areas (windows, doors, etc.). Then return
    (final_wwr, wwr_range_used).

    Parameters
    ----------
    building_row : dict
        A dictionary of building attributes (function, type, age_range, etc.).
    scenario : str
        E.g. "scenario1".
    calibration_stage : str
        E.g. "pre_calibration".
    strategy : str
        "A" => pick midpoint in ranges; "B" => pick random uniform.
    random_seed : int
        If you want reproducible random picks.
    user_config_fenez : dict
        Optional override dictionary for fenestration parameters (WWR, materials, etc.).
    use_computed_wwr : bool
        If True => compute the WWR from the sub-element areas in materials_config.py.
        If False => use the wwr range & final wwr from the dictionary.
    include_doors_in_wwr : bool
        If True => treat door area as part of fenestration area when computing WWR.

    Returns
    -------
    (final_wwr, wwr_range_used) : (float, tuple or None)
        final_wwr => the numeric WWR (0.0â€“1.0).
        wwr_range_used => the range that was used to pick the WWR, or None if computed.
    """

    # 1) Identify building function & type
    bldg_func = building_row.get("building_function", "residential")
    if bldg_func.lower() == "residential":
        building_type = building_row.get("residential_type", "UnknownHouseType")
    else:
        building_type = building_row.get("non_residential_type", "UnknownNonResType")

    # 2) Age range & scenario
    age_range = building_row.get("age_range", "2015 and later")

    # 3) Retrieve all fenestration/material data
    #    This returns a dict containing e.g.:
    #    {
    #      "wwr": 0.32,
    #      "wwr_range_used": (0.3, 0.35),
    #      "elements": {...},
    #      ...
    #    }
    data = get_extended_materials_data(
        building_function=bldg_func,
        building_type=building_type,
        age_range=age_range,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=user_config_fenez
    )

    # 4) Decide how to finalize the WWR
    #    By default, we use data["wwr"] which was either:
    #      - random/midpoint pick from wwr_range
    #      - or user_config_fenez["wwr"] if present
    final_wwr = data["wwr"]
    wwr_range_used = data.get("wwr_range_used", None)

    if use_computed_wwr:
        # Overwrite final_wwr by actually computing from the sub-element areas
        elements_dict = data.get("elements", {})
        final_wwr = compute_wwr(elements_dict, include_doors=include_doors_in_wwr)
        # In this scenario, we might say wwr_range_used = None
        wwr_range_used = None

    return final_wwr, wwr_range_used

  --- File Contents End ---

  File: data_materials_non_residential.py
  --- File Contents Start ---
non_residential_materials_data = {
    ('Accommodation Function', '1945-1964', 'scenario1', 'post_calibration'): {
        "roughness": "MediumRough",
        "wwr_range": (0.19, 0.24),
        "material_opaque_lookup": "DoorPanel_Range",
        "material_window_lookup": "Glazing_Clear_3mm",
        "doors": {
            "area_m2": 6.5,
            "R_value_range": (None, None),
            "U_value_range": (2.7, 2.7),
            "material_opaque_lookup": "DoorPanel_Range",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "exterior_wall": {
            "area_m2": 155.0,
            "R_value_range": (2.7, 2.7),
            "U_value_range": (0.2, 0.2),
            "material_opaque_lookup": "Concrete_200mm",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "flat_roof": {
            "area_m2": 125.0,
            "R_value_range": (2.7, 2.7),
            "U_value_range": (0.2, 0.2),
            "material_opaque_lookup": "Insulated_Roof_R5",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "ground_floor": {
            "area_m2": 75.0,
            "R_value_range": (2.7, 2.7),
            "U_value_range": (0.22, 0.22),
            "material_opaque_lookup": "GroundContactFloor_Generic",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "inter_floor": {
            "area_m2": 60.0,
            "R_value_range": (2.0, 2.0),
            "U_value_range": (0.5, 0.5),
            "material_opaque_lookup": "InternalFloor_Generic",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "interior_wall": {
            "area_m2": 50.0,
            "R_value_range": (1.5, 1.5),
            "U_value_range": (0.67, 0.67),
            "material_opaque_lookup": "InteriorWall_Generic",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "windows": {
            "area_m2": 14.0,
            "R_value_range": (None, None),
            "U_value_range": (2.7, 2.7),
            "material_opaque_lookup": "DoorPanel_Range",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
    },

    ('Accommodation Function', '1945-1964', 'scenario1', 'pre_calibration'): {
        "roughness": "MediumRough",
        "wwr_range": (0.19, 0.24),
        "material_opaque_lookup": "DoorPanel_Range",
        "material_window_lookup": "Glazing_Clear_3mm",
        "doors": {
            "area_m2": 6.5,
            "R_value_range": (None, None),
            "U_value_range": (2.7, 2.7),
            "material_opaque_lookup": "DoorPanel_Range",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "exterior_wall": {
            "area_m2": 155.0,
            ....
  --- File Contents End ---

  File: data_materials_residential.py
  --- File Contents Start ---
residential_materials_data = {
    ('Apartment', '1946-1964', 'scenario1', 'post_calibration'): {
        "roughness": "MediumRough",
        "wwr_range": (0.22, 0.22),
        "material_opaque_lookup": "DoorPanel_Range",
        "material_window_lookup": "Glazing_Clear_3mm",
        "doors": {
            "area_m2": 5.67,
            "R_value_range": (None, None),
            "U_value_range": (3.4, 3.4),
            "material_opaque_lookup": "DoorPanel_Range",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "exterior_wall": {
            "area_m2": 25.03,
            "R_value_range": (0.35, 1.92),
            "U_value_range": (1.92, 1.92),
            "material_opaque_lookup": "Concrete_200mm",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "flat_roof": {
            "area_m2": 57.25,
            "R_value_range": (0.22, 2.56),
            "U_value_range": (2.37, 2.56),
            "material_opaque_lookup": "Insulated_Roof_R5",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "ground_floor": {
            "area_m2": 22.33,
            "R_value_range": (0.15, 0.15),
            "U_value_range": (2.44, 2.44),
            "material_opaque_lookup": "GroundContactFloor_Generic",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "inter_floor": {
            "area_m2": 60.0,
            "R_value_range": (2.0, 2.0),
            "U_value_range": (0.5, 0.5),
            "material_opaque_lookup": "InternalFloor_Generic",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "interior_wall": {
            "area_m2": 50.0,
            "R_value_range": (1.5, 1.5),
            "U_value_range": (0.67, 0.67),
            "material_opaque_lookup": "InteriorWall_Generic",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
        "windows": {
            "area_m2": 19.86,
            "R_value_range": (None, None),
            "U_value_range": (1.4, 5.1),
            "material_opaque_lookup": "DoorPanel_Range",
            "material_window_lookup": "Glazing_Clear_3mm",
        },
    },

    ('Apartment', '1946-1964', 'scenario1', 'pre_calibration'): {
        "roughness": "MediumRough",
        "wwr_range": (0.22, 0.22),
        "material_opaque_lookup": "DoorPanel_Range",
        ....
  --- File Contents End ---

  File: dict_override_excel.py
  --- File Contents Start ---
# fenez/dict_override_excel.py

import pandas as pd
import copy
import math

def override_dictionaries_from_excel(
    excel_path,
    default_res_data,
    default_nonres_data,
    default_roughness="MediumRough",
    fallback_wwr_range=(0.2, 0.3)
):
    """
    Reads an Excel file containing envelope data (including min_wwr, max_wwr,
    R_value_min, R_value_max, etc.) and uses it to override or extend
    the default dictionaries for residential and non_residential materials.

    The Excel must contain columns like:
      - building_function : 'residential' or 'non_residential'
      - building_type
      - year_range
      - scenario
      - calibration_stage
      - element : e.g. 'exterior_wall', 'windows', 'doors', etc.
      - area_m2
      - R_value_min, R_value_max
      - U_value_min, U_value_max
      - roughness
      - material_opaque_lookup
      - material_window_lookup
      - min_wwr, max_wwr

    For each row, we locate or create the dictionary entry in either:
      default_res_data[(btype, yrange, scen, stage)] or
      default_nonres_data[(btype, yrange, scen, stage)]

    Then we override sub-keys like:
      data_entry["wwr_range"] = (min_wwr, max_wwr)
      data_entry[element]["R_value_range"] = (R_value_min, R_value_max)
      data_entry[element]["U_value_range"] = (U_value_min, U_value_max)

    Returns
    -------
    new_res_data : dict
    new_nonres_data : dict

    Example usage:
      new_res, new_nonres = override_dictionaries_from_excel(
          "envelop.xlsx", residential_materials_data, non_residential_materials_data
      )
    """
    # Make deep copies so we don't mutate originals
    new_res_data = copy.deepcopy(default_res_data)
    new_nonres_data = copy.deepcopy(default_nonres_data)

    # Load Excel
    df = pd.read_excel(excel_path)

    required_cols = [
        "building_function",
        "building_type",
        "year_range",
        "scenario",
        "calibration_stage",
        "element",
        "area_m2",
        "R_value_min",
        "R_value_max",
        "U_value_min",
        "U_value_max",
        "roughness",
        "material_opaque_lookup",
        "material_window_lookup",
        "min_wwr",
        "max_wwr"
    ]
    missing_cols = [c for c in required_cols if c not in df.columns]
    if missing_cols:
        raise ValueError(f"Excel file is missing required columns: {missing_cols}")

    for _, row in df.iterrows():
        bfunc = str(row["building_function"]).strip().lower()  # 'residential' or 'non_residential'
        btype = str(row["building_type"]).strip()
        yrange = str(row["year_range"]).strip()
        scen   = str(row["scenario"]).strip()
        stage  = str(row["calibration_stage"]).strip()
        elem_name = str(row["element"]).strip()

        # Decide which dictionary to modify
        if bfunc == "residential":
            current_dict = new_res_data
        else:
            current_dict = new_nonres_data

        dict_key = (btype, yrange, scen, stage)

        # Create or fetch the entry
        if dict_key not in current_dict:
            current_dict[dict_key] = {
                "roughness": default_roughness,
                "wwr_range": fallback_wwr_range
            }
        data_entry = current_dict[dict_key]

        # Possibly override top-level roughness
        rgh_val = str(row["roughness"]).strip()
        if rgh_val.lower() != "nan":
            data_entry["roughness"] = rgh_val

        # Possibly override top-level wwr_range
        min_wwr = row["min_wwr"]
        max_wwr = row["max_wwr"]
        if pd.notna(min_wwr) and pd.notna(max_wwr):
            data_entry["wwr_range"] = (float(min_wwr), float(max_wwr))

        # Now handle the sub-element (doors, windows, exterior_wall, etc.)
        if elem_name not in data_entry:
            data_entry[elem_name] = {}

        elem_dict = data_entry[elem_name]

        # area
        if pd.notna(row["area_m2"]):
            elem_dict["area_m2"] = float(row["area_m2"])

        # R_value_range
        r_min = row["R_value_min"]
        r_max = row["R_value_max"]
        if pd.notna(r_min) and pd.notna(r_max):
            elem_dict["R_value_range"] = (float(r_min), float(r_max))

        # U_value_range
        u_min = row["U_value_min"]
        u_max = row["U_value_max"]
        if pd.notna(u_min) and pd.notna(u_max):
            elem_dict["U_value_range"] = (float(u_min), float(u_max))

        # Overwrite or store roughness for that element if needed
        # (Often we keep the top-level roughness, but you could do:
        # elem_dict["roughness"] = data_entry["roughness"])

        # material_opaque_lookup
        opq_lookup = row["material_opaque_lookup"]
        if pd.notna(opq_lookup):
            elem_dict["material_opaque_lookup"] = str(opq_lookup).strip()

        # material_window_lookup
        win_lookup = row["material_window_lookup"]
        if pd.notna(win_lookup):
            elem_dict["material_window_lookup"] = str(win_lookup).strip()

    return new_res_data, new_nonres_data

  --- File Contents End ---

  File: fenestration.py
  --- File Contents Start ---
# fenez/fenestration.py

def add_fenestration(
    idf,
    building_row,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config_fenez=None,
    assigned_fenez_log=None,
    use_computed_wwr=False,
    include_doors_in_wwr=False
):
    """
    1) Compute or retrieve the final WWR using assign_fenestration_parameters(...).
    2) Remove existing FENESTRATIONSURFACE:DETAILED from the IDF.
    3) Use geomeppy.IDF.set_wwr(...) to create new window surfaces referencing "Window1C".
    4) (Optional) Log WWR range used, plus the new fenestration surface names.

    Parameters
    ----------
    idf : geomeppy.IDF
        The IDF to modify
    building_row : dict
        Contains building info (ogc_fid, function, type, etc.)
    scenario, calibration_stage, strategy, random_seed : str / int
        Passed through to assign_fenestration_parameters
    user_config_fenez : dict
        Optional overrides for fenestration
    assigned_fenez_log : dict
        If provided, we log WWR picks & fenestration object names under
        assigned_fenez_log[building_id].
    use_computed_wwr : bool
        If True, compute WWR from sub-element areas (windows, doors, etc.),
        else pick from wwr_range in the dictionary.
    include_doors_in_wwr : bool
        If True, door area is included in the fenestration area for the WWR ratio.
    """

    from geomeppy import IDF as GeppyIDF
    from .assign_fenestration_values import assign_fenestration_parameters

    # 1) Assign fenestration parameters (including final WWR).
    wwr, wwr_range_used = assign_fenestration_parameters(
        building_row=building_row,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=user_config_fenez,
        use_computed_wwr=use_computed_wwr,
        include_doors_in_wwr=include_doors_in_wwr
        # assigned_fenez_log is not passed here, so
        # we do our own logging below in this function
    )

    # (Optional) Log the final WWR, WWR range in assigned_fenez_log
    bldg_id = building_row.get("ogc_fid", None)
    if assigned_fenez_log and bldg_id is not None:
        if bldg_id not in assigned_fenez_log:
            assigned_fenez_log[bldg_id] = {}
        assigned_fenez_log[bldg_id]["fenez_final_wwr"] = wwr
        if wwr_range_used is not None:
            assigned_fenez_log[bldg_id]["fenez_wwr_range_used"] = wwr_range_used

    # 2) Remove any existing fenestration objects
    fen_objects = idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]
    del fen_objects[:]

    # 3) Use geomeppy to create new window surfaces
    #    We assume the construction "Window1C" exists in the IDF
    GeppyIDF.set_wwr(idf, wwr=wwr, construction="Window1C")

    # 4) (Optional) After creating them, log the new fenestration surface names.
    new_fens = idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]
    if assigned_fenez_log and bldg_id is not None and new_fens:
        assigned_fenez_log[bldg_id]["fenez_fenestration_objects"] = [
            fen.Name for fen in new_fens
        ]

    print(f"[add_fenestration] Building: {bldg_id} => WWR={wwr:.3f}, used Window1C")

  --- File Contents End ---

  File: materials.py
  --- File Contents Start ---
# fenez/materials.py

from geomeppy import IDF
from .materials_config import get_extended_materials_data

def _store_material_picks(assigned_fenez_log, building_id, label, mat_data):
    """
    A helper to store final material picks (and any range fields) in assigned_fenez_log[building_id].
    `label` might be "top_opq", "top_win", or "exterior_wall_opq", etc.

    We'll flatten the dict so that each key becomes:
      "fenez_{label}.{key}" => value

    Example:
      if label == "top_opq" and mat_data == {
         "obj_type": "MATERIAL",
         "Thickness": 0.2,
         "Thickness_range": (0.15, 0.25),
         ...
      }
      we'll store assigned_fenez_log[building_id]["fenez_top_opq.obj_type"] = "MATERIAL"
      assigned_fenez_log[building_id]["fenez_top_opq.Thickness_range"] = (0.15, 0.25), etc.
    """
    if not mat_data:
        return

    if building_id not in assigned_fenez_log:
        assigned_fenez_log[building_id] = {}

    for k, v in mat_data.items():
        # Flatten as "fenez_{label}.{key}"
        assigned_fenez_log[building_id][f"fenez_{label}.{k}"] = v


def update_construction_materials(
    idf,
    building_row,
    building_index=None,
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config_fenez=None,
    assigned_fenez_log=None
):
    """
    1) Calls get_extended_materials_data(...) => returns a dict with final picks
       (including sub-element R/U and range fields).
    2) Removes all existing Materials & Constructions from the IDF (clean slate).
    3) Creates new Opaque & Window materials => including top-level fallback
       so geometry references remain valid.
    4) Creates distinct sub-element-based materials & constructions (e.g. "exterior_wall_Construction").
    5) Logs assigned final picks (and ranges) into assigned_fenez_log if provided.

    Returns
    -------
    construction_map : dict
        Maps sub-element name => construction name
        (e.g. {"exterior_wall": "exterior_wall_Construction", ...}).
    """
    # 1) Figure out building_id for logging
    building_id = building_row.get("ogc_fid", None)
    if building_id is None:
        building_id = building_index

    # 2) Retrieve extended materials data (with overrides)
    data = get_extended_materials_data(
        building_function=building_row.get("building_function", "residential"),
        building_type=(building_row.get("residential_type", "")
                       if building_row.get("building_function","").lower() == "residential"
                       else building_row.get("non_residential_type","")),
        age_range=building_row.get("age_range", "2015 and later"),
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_fenez=user_config_fenez
    )

    mat_opq = data.get("material_opaque", None)
    mat_win = data.get("material_window", None)
    elements_data = data.get("elements", {})

    # 2b) If logging final picks + ranges, store them now
    if assigned_fenez_log is not None and building_id is not None:
        # <-- NEW: ensure we have a sub-dict
        if building_id not in assigned_fenez_log:
            assigned_fenez_log[building_id] = {}
            
        # Log top-level data: "roughness", "wwr_range_used", "wwr", etc.
        for top_key in ["roughness", "wwr_range_used", "wwr"]:
            if top_key in data:
                assigned_fenez_log[building_id][f"fenez_{top_key}"] = data[top_key]

        # Also store the top-level opaque and window material details
        _store_material_picks(assigned_fenez_log, building_id, "top_opq", mat_opq)
        _store_material_picks(assigned_fenez_log, building_id, "top_win", mat_win)

        # For each sub-element, store final picks + ranges
        for elem_name, elem_data in elements_data.items():
            # e.g. store "exterior_wall_R_value", "exterior_wall_R_value_range_used"
            if "R_value" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_R_value"] = elem_data["R_value"]
            if "R_value_range_used" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_R_value_range_used"] = elem_data["R_value_range_used"]

            if "U_value" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_U_value"] = elem_data["U_value"]
            if "U_value_range_used" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_U_value_range_used"] = elem_data["U_value_range_used"]

            if "area_m2" in elem_data:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_area_m2"] = elem_data["area_m2"]

            # Now store the sub-element's opaque & window material dict
            opq_sub = elem_data.get("material_opaque", None)
            win_sub = elem_data.get("material_window", None)
            _store_material_picks(assigned_fenez_log, building_id, f"{elem_name}_opq", opq_sub)
            _store_material_picks(assigned_fenez_log, building_id, f"{elem_name}_win", win_sub)

    # 3) Remove existing Materials & Constructions from the IDF
    for obj_type in [
        "MATERIAL",
        "MATERIAL:NOMASS",
        "WINDOWMATERIAL:GLAZING",
        "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM",
        "CONSTRUCTION"
    ]:
        for obj in idf.idfobjects[obj_type][:]:
            idf.removeidfobject(obj)

    def create_opaque_material(idf, mat_data, mat_name):
        if mat_data["obj_type"].upper() == "MATERIAL":
            mat_obj = idf.newidfobject("MATERIAL")
            mat_obj.Name = mat_name
            mat_obj.Roughness = mat_data.get("Roughness", "MediumRough")
            mat_obj.Thickness = mat_data["Thickness"]
            mat_obj.Conductivity = mat_data["Conductivity"]
            mat_obj.Density = mat_data["Density"]
            mat_obj.Specific_Heat = mat_data["Specific_Heat"]
            mat_obj.Thermal_Absorptance = mat_data["Thermal_Absorptance"]
            mat_obj.Solar_Absorptance   = mat_data["Solar_Absorptance"]
            mat_obj.Visible_Absorptance = mat_data["Visible_Absorptance"]
            return mat_obj.Name

        elif mat_data["obj_type"].upper() == "MATERIAL:NOMASS":
            mat_obj = idf.newidfobject("MATERIAL:NOMASS")
            mat_obj.Name = mat_name
            mat_obj.Roughness = mat_data.get("Roughness", "MediumRough")
            mat_obj.Thermal_Resistance = mat_data["Thermal_Resistance"]
            mat_obj.Thermal_Absorptance = mat_data["Thermal_Absorptance"]
            mat_obj.Solar_Absorptance   = mat_data["Solar_Absorptance"]
            mat_obj.Visible_Absorptance = mat_data["Visible_Absorptance"]
            return mat_obj.Name

        return None

    def create_window_material(idf, mat_data, mat_name):
        wtype = mat_data["obj_type"].upper()
        if wtype == "WINDOWMATERIAL:GLAZING":
            wmat = idf.newidfobject("WINDOWMATERIAL:GLAZING")
            wmat.Name = mat_name
            wmat.Optical_Data_Type = mat_data.get("Optical_Data_Type", "SpectralAverage")
            wmat.Thickness = mat_data["Thickness"]
            wmat.Solar_Transmittance_at_Normal_Incidence = mat_data["Solar_Transmittance"]
            wmat.Front_Side_Solar_Reflectance_at_Normal_Incidence = mat_data["Front_Solar_Reflectance"]
            wmat.Back_Side_Solar_Reflectance_at_Normal_Incidence  = mat_data["Back_Solar_Reflectance"]
            wmat.Visible_Transmittance_at_Normal_Incidence        = mat_data["Visible_Transmittance"]
            wmat.Front_Side_Visible_Reflectance_at_Normal_Incidence = mat_data["Front_Visible_Reflectance"]
            wmat.Back_Side_Visible_Reflectance_at_Normal_Incidence  = mat_data["Back_Visible_Reflectance"]
            wmat.Infrared_Transmittance_at_Normal_Incidence         = mat_data["IR_Transmittance"]
            wmat.Front_Side_Infrared_Hemispherical_Emissivity       = mat_data["Front_IR_Emissivity"]
            wmat.Back_Side_Infrared_Hemispherical_Emissivity        = mat_data["Back_IR_Emissivity"]
            wmat.Conductivity = mat_data["Conductivity"]
            wmat.Dirt_Correction_Factor_for_Solar_and_Visible_Transmittance = mat_data["Dirt_Correction_Factor"]
            wmat.Solar_Diffusing = mat_data["Solar_Diffusing"]
            return wmat.Name

        elif wtype == "WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM":
            wmat = idf.newidfobject("WINDOWMATERIAL:SIMPLEGLAZINGSYSTEM")
            wmat.Name = mat_name
            # If you want to set UFactor, SHGC, etc., do it here
            return wmat.Name

        return None

    # 4) Create top-level fallback Materials & Constructions
    opq_name = None
    if mat_opq:
        opq_name = create_opaque_material(idf, mat_opq, mat_opq["Name"])
        # Log the top-level opaque material name
        if assigned_fenez_log and building_id is not None and opq_name:
            assigned_fenez_log[building_id]["fenez_top_opaque_material_name"] = opq_name

    win_name = None
    if mat_win:
        win_name = create_window_material(idf, mat_win, mat_win["Name"])
        # Log the top-level window material name
        if assigned_fenez_log and building_id is not None and win_name:
            assigned_fenez_log[building_id]["fenez_top_window_material_name"] = win_name

    # Create fallback Constructions (CEILING1C, Window1C, etc.)
    if opq_name:
        c_ceil = idf.newidfobject("CONSTRUCTION")
        c_ceil.Name = "CEILING1C"
        c_ceil.Outside_Layer = opq_name

        c_ext = idf.newidfobject("CONSTRUCTION")
        c_ext.Name = "Ext_Walls1C"
        c_ext.Outside_Layer = opq_name

        c_intw = idf.newidfobject("CONSTRUCTION")
        c_intw.Name = "Int_Walls1C"
        c_intw.Outside_Layer = opq_name

        c_roof = idf.newidfobject("CONSTRUCTION")
        c_roof.Name = "Roof1C"
        c_roof.Outside_Layer = opq_name

        c_grnd = idf.newidfobject("CONSTRUCTION")
        c_grnd.Name = "GroundFloor1C"
        c_grnd.Outside_Layer = opq_name

        c_ifloor = idf.newidfobject("CONSTRUCTION")
        c_ifloor.Name = "IntFloor1C"
        c_ifloor.Outside_Layer = opq_name

        # If needed, log each fallback construction name

    if win_name:
        c_win = idf.newidfobject("CONSTRUCTION")
        c_win.Name = "WINDOW1C"
        c_win.Outside_Layer = win_name

        if assigned_fenez_log and building_id is not None:
            assigned_fenez_log[building_id]["fenez_window1C_construction"] = c_win.Name

    # 5) Create sub-element-based Materials & Constructions
    construction_map = {}
    for elem_name, elem_data in elements_data.items():
        mat_opq_sub = elem_data.get("material_opaque", None)
        mat_win_sub = elem_data.get("material_window", None)

        opq_sub_name = None
        win_sub_name = None

        # create opaque
        if mat_opq_sub:
            sub_opq_name = f"{elem_name}_OpaqueMat"
            opq_sub_name = create_opaque_material(idf, mat_opq_sub, sub_opq_name)
            # Log the actual E+ material name
            if assigned_fenez_log and building_id is not None and opq_sub_name:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_opq_material_name"] = opq_sub_name

        # create window
        if mat_win_sub:
            sub_win_name = f"{elem_name}_WindowMat"
            win_sub_name = create_window_material(idf, mat_win_sub, sub_win_name)
            # Log the actual E+ material name
            if assigned_fenez_log and building_id is not None and win_sub_name:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_win_material_name"] = win_sub_name

        # create new Opaque Construction
        if opq_sub_name:
            c_sub = idf.newidfobject("CONSTRUCTION")
            c_sub.Name = f"{elem_name}_Construction"
            c_sub.Outside_Layer = opq_sub_name
            construction_map[elem_name] = c_sub.Name

            if assigned_fenez_log and building_id is not None:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_construction_name"] = c_sub.Name

        # Optional: create a separate window construction
        if win_sub_name:
            c_sub_win = idf.newidfobject("CONSTRUCTION")
            c_sub_win.Name = f"{elem_name}_WindowConst"
            c_sub_win.Outside_Layer = win_sub_name
            construction_map[f"{elem_name}_window"] = c_sub_win.Name

            if assigned_fenez_log and building_id is not None:
                assigned_fenez_log[building_id][f"fenez_{elem_name}_window_construction_name"] = c_sub_win.Name

    print("[update_construction_materials] => Created fallback top-level constructions (CEILING1C, etc.).")
    print("[update_construction_materials] => Created sub-element-based constructions:")
    for k, v in construction_map.items():
        print(f"   {k} => {v}")

    return construction_map


def assign_constructions_to_surfaces(idf, construction_map):
    """
    Assign each BUILDINGSURFACE:DETAILED to a suitable construction name
    based on sub-element keys and boundary conditions.

    construction_map: e.g.
      {
        "exterior_wall": "exterior_wall_Construction",
        "exterior_wall_window": "exterior_wall_WindowConst",
        "ground_floor": "ground_floor_Construction",
        ...
      }
    """
    for surface in idf.idfobjects["BUILDINGSURFACE:DETAILED"]:
        s_type = surface.Surface_Type.upper()
        bc = surface.Outside_Boundary_Condition.upper()

        if s_type == "WALL":
            if bc == "OUTDOORS":
                if "exterior_wall" in construction_map:
                    surface.Construction_Name = construction_map["exterior_wall"]
                else:
                    surface.Construction_Name = "Ext_Walls1C"
            elif bc in ["SURFACE", "ADIABATIC"]:
                if "interior_wall" in construction_map:
                    surface.Construction_Name = construction_map["interior_wall"]
                else:
                    surface.Construction_Name = "Int_Walls1C"
            else:
                surface.Construction_Name = "Ext_Walls1C"

        elif s_type == "ROOF":
            if bc == "OUTDOORS":
                if "flat_roof" in construction_map:
                    surface.Construction_Name = construction_map["flat_roof"]
                else:
                    surface.Construction_Name = "Roof1C"
            else:
                surface.Construction_Name = "Int_Walls1C"

        elif s_type == "CEILING":
            if bc in ["SURFACE", "ADIABATIC"]:
                if "inter_floor" in construction_map:
                    surface.Construction_Name = construction_map["inter_floor"]
                else:
                    surface.Construction_Name = "IntFloor1C"
            else:
                surface.Construction_Name = "CEILING1C"

        elif s_type == "FLOOR":
            if bc == "GROUND":
                if "ground_floor" in construction_map:
                    surface.Construction_Name = construction_map["ground_floor"]
                else:
                    surface.Construction_Name = "GroundFloor1C"
            elif bc in ["SURFACE", "ADIABATIC"]:
                if "inter_floor" in construction_map:
                    surface.Construction_Name = construction_map["inter_floor"]
                else:
                    surface.Construction_Name = "IntFloor1C"
            else:
                surface.Construction_Name = "GroundFloor1C"
        else:
            # fallback
            surface.Construction_Name = "Ext_Walls1C"

    # Fenestrations
    for fen in idf.idfobjects["FENESTRATIONSURFACE:DETAILED"]:
        # If there's a sub-element key "windows" in the construction_map
        if "windows" in construction_map:
            fen.Construction_Name = construction_map["windows"]
        else:
            fen.Construction_Name = "Window1C"

    print("[assign_constructions_to_surfaces] => Surfaces assigned via sub-element logic.")

  --- File Contents End ---

  File: materials_config.py
  --- File Contents Start ---
# fenez/materials_config.py

import random
from .data_materials_residential import residential_materials_data
from .data_materials_non_residential import non_residential_materials_data
from .materials_lookup import material_lookup

###############################################################################
#   pick_val(...) & assign_material_from_lookup(...) helper functions
###############################################################################

def pick_val(rng, strategy="A"):
    """
    Helper to pick a single float from (min_val, max_val).
    If rng=(x,x), return x.
    If strategy="A", pick the midpoint. If "B", pick random uniform in the range.
    Otherwise, fallback to rng[0].
    """
    if not rng or len(rng) < 2:
        return None
    min_val, max_val = rng
    if min_val is None and max_val is None:
        return None
    if min_val is not None and max_val is not None:
        if min_val == max_val:
            return min_val
        if strategy == "A":
            return (min_val + max_val) / 2.0
        elif strategy == "B":
            return random.uniform(min_val, max_val)
        else:
            # fallback => pick min
            return min_val
    # If one side is None, you could handle that or just return min
    return min_val if min_val is not None else max_val


def assign_material_from_lookup(mat_def: dict, strategy="A"):
    """
    Takes a dict from material_lookup, which has fields like "Thickness_range",
    "Conductivity_range", etc. Returns a *copy* with final numeric picks assigned.

    # NEW OR CHANGED:
    # This function remains mostly the same, but you can store the picked range
    # in the returned dict if you want. For instance, final_mat["Thickness_range_used"] = ...
    """
    final_mat = dict(mat_def)  # shallow copy to preserve original
    obj_type = final_mat["obj_type"].upper()

    # Extract the relevant ranges for convenience
    thick_rng = final_mat.get("Thickness_range", None)
    cond_rng  = final_mat.get("Conductivity_range", None)

    if obj_type == "MATERIAL":
        # mass-based
        final_mat["Thickness"] = pick_val(thick_rng, strategy)
        final_mat["Conductivity"] = pick_val(cond_rng, strategy)
        final_mat["Density"] = pick_val(final_mat.get("Density_range", (2300, 2300)), strategy)
        final_mat["Specific_Heat"] = pick_val(final_mat.get("Specific_Heat_range", (900, 900)), strategy)
        final_mat["Thermal_Absorptance"] = pick_val(final_mat.get("Thermal_Absorptance_range", (0.9, 0.9)), strategy)
        final_mat["Solar_Absorptance"]   = pick_val(final_mat.get("Solar_Absorptance_range", (0.7, 0.7)), strategy)
        final_mat["Visible_Absorptance"] = pick_val(final_mat.get("Visible_Absorptance_range", (0.7, 0.7)), strategy)

    elif obj_type == "MATERIAL:NOMASS":
        # no-mass => thermal_resistance
        r_rng = final_mat.get("Thermal_Resistance_range", None)
        final_mat["Thermal_Resistance"] = pick_val(r_rng, strategy)
        final_mat["Thermal_Absorptance"] = pick_val(final_mat.get("Thermal_Absorptance_range", (0.9, 0.9)), strategy)
        final_mat["Solar_Absorptance"]   = pick_val(final_mat.get("Solar_Absorptance_range", (0.7, 0.7)), strategy)
        final_mat["Visible_Absorptance"] = pick_val(final_mat.get("Visible_Absorptance_range", (0.7, 0.7)), strategy)

    elif obj_type == "WINDOWMATERIAL:GLAZING":
        # single-pane or multi-pane glass
        final_mat["Thickness"] = pick_val(thick_rng, strategy)
        final_mat["Solar_Transmittance"] = pick_val(final_mat.get("Solar_Transmittance_range", (0.76, 0.76)), strategy)
        final_mat["Front_Solar_Reflectance"] = pick_val(final_mat.get("Front_Solar_Reflectance_range", (0.07, 0.07)), strategy)
        final_mat["Back_Solar_Reflectance"]  = pick_val(final_mat.get("Back_Solar_Reflectance_range", (0.07, 0.07)), strategy)
        final_mat["Visible_Transmittance"]   = pick_val(final_mat.get("Visible_Transmittance_range", (0.86, 0.86)), strategy)
        final_mat["Front_Visible_Reflectance"] = pick_val(final_mat.get("Front_Visible_Reflectance_range", (0.06, 0.06)), strategy)
        final_mat["Back_Visible_Reflectance"]  = pick_val(final_mat.get("Back_Visible_Reflectance_range", (0.06, 0.06)), strategy)
        final_mat["Front_IR_Emissivity"]       = pick_val(final_mat.get("Front_IR_Emissivity_range", (0.84, 0.84)), strategy)
        final_mat["Back_IR_Emissivity"]        = pick_val(final_mat.get("Back_IR_Emissivity_range", (0.84, 0.84)), strategy)
        final_mat["Conductivity"]              = pick_val(cond_rng, strategy)
        final_mat["Dirt_Correction_Factor"]    = pick_val(final_mat.get("Dirt_Correction_Factor_range", (1.0, 1.0)), strategy)
        # IR_Transmittance is usually zero, so we keep as is

    else:
        # fallback - do nothing special
        pass

    return final_mat


###############################################################################
#   The main function to retrieve data and combine user overrides (ranges + final)
###############################################################################

def compute_wwr(elements_dict, include_doors=False):
    """
    Compute WWR => (window area) / (external wall area).
    If include_doors=True, add door area as part of fenestration.
    """
    external_wall_area = 0.0
    if "exterior_wall" in elements_dict:
        external_wall_area += elements_dict["exterior_wall"].get("area_m2", 0.0)
    # If your data uses e.g. "solid_wall", etc., you can accumulate similarly.

    window_area = elements_dict.get("windows", {}).get("area_m2", 0.0)
    if include_doors and "doors" in elements_dict:
        window_area += elements_dict["doors"].get("area_m2", 0.0)

    if external_wall_area > 0:
        return window_area / external_wall_area
    else:
        return 0.0


def get_extended_materials_data(
    building_function: str,
    building_type: str,
    age_range: str,
    scenario: str,
    calibration_stage: str,
    strategy: str = "A",
    random_seed=None,
    user_config_fenez=None
):
    """
    1) Looks up either residential_materials_data or non_residential_materials_data
       by (building_type, age_range, scenario, calibration_stage).
    2) Picks from wwr_range => final wwr.
    3) Also grabs top-level 'material_opaque_lookup', 'material_window_lookup' if any.
    4) Then for sub-elements => e.g. ground_floor, windows, doors => picks R_value, U_value,
       area, etc., plus references to 'material_opaque_lookup' or 'material_window_lookup' if present.
    5) user_config_fenez can override the final picks, the range picks, or both.
    6) We recompute 'Conductivity' or 'Thermal_Resistance' so the final R or U from data dictionary is used.
    7) Returns a dictionary with all final picks (and new "xxx_range_used" fields).

    # NEW OR CHANGED:
    # - We'll also store "xxx_range_used" so that you can record what range was used
    #   before picking the final value. Then in materials.py, you can log it in assigned_fenez_log.
    # - We handle user_config_fenez that might override "R_value_range", "U_value_range", etc.
    """

    if random_seed is not None:
        random.seed(random_seed)

    # decide data source
    if building_function.lower() == "residential":
        ds = residential_materials_data
    else:
        ds = non_residential_materials_data

    dict_key = (building_type, age_range, scenario, calibration_stage)
    if dict_key not in ds:
        # fallback
        output_fallback = {
            "roughness": "MediumRough",
            "wwr": 0.3,
            "wwr_range_used": (0.3, 0.3),  # logging the fallback range
            "material_opaque": None,
            "material_window": None,
            "elements": {}
        }

        # Possibly let user_config_fenez override top-level WWR or WWR range
        if user_config_fenez:
            # override wwr range if present
            if "wwr_range" in user_config_fenez:
                output_fallback["wwr_range_used"] = user_config_fenez["wwr_range"]
            # final wwr
            if "wwr" in user_config_fenez:
                output_fallback["wwr"] = user_config_fenez["wwr"]

        return output_fallback

    data_entry = ds[dict_key]

    # Pick or override wwr range
    default_wwr_range = data_entry.get("wwr_range", (0.3, 0.3))
    if user_config_fenez and "wwr_range" in user_config_fenez:
        default_wwr_range = user_config_fenez["wwr_range"]  # override the range

    # Now pick final wwr from that range
    wwr_val = pick_val(default_wwr_range, strategy)

    # Possibly override the final wwr if user_config_fenez["wwr"] is present
    if user_config_fenez and "wwr" in user_config_fenez:
        wwr_val = user_config_fenez["wwr"]

    # top-level roughness
    rough_str = data_entry.get("roughness", "MediumRough")

    # top-level opaque & window (before user overrides)
    mat_opq_key = data_entry.get("material_opaque_lookup", None)
    mat_win_key = data_entry.get("material_window_lookup", None)

    # If user_config_fenez overrides these lookups
    if user_config_fenez:
        if "material_opaque_lookup" in user_config_fenez:
            mat_opq_key = user_config_fenez["material_opaque_lookup"]
        if "material_window_lookup" in user_config_fenez:
            mat_win_key = user_config_fenez["material_window_lookup"]

    # create final picks for top-level materials
    final_opq = None
    if mat_opq_key and mat_opq_key in material_lookup:
        final_opq = assign_material_from_lookup(material_lookup[mat_opq_key], strategy)
    final_win = None
    if mat_win_key and mat_win_key in material_lookup:
        final_win = assign_material_from_lookup(material_lookup[mat_win_key], strategy)

    # sub-elements
    possible_elems = [
        "ground_floor", "exterior_wall", "flat_roof", "sloping_flat_roof",
        "inter_floor", "interior_wall", "windows", "doors"
    ]
    elements = {}
    for elem_name in possible_elems:
        if elem_name in data_entry:
            subd = dict(data_entry[elem_name])  # shallow copy
            # (A) possibly override sub-element's R_value_range, U_value_range, area_m2, etc.
            if user_config_fenez and "elements" in user_config_fenez:
                user_elem_config = user_config_fenez["elements"].get(elem_name, {})
                # override sub-element range if found
                if "R_value_range" in user_elem_config:
                    subd["R_value_range"] = user_elem_config["R_value_range"]
                if "U_value_range" in user_elem_config:
                    subd["U_value_range"] = user_elem_config["U_value_range"]
                if "area_m2" in user_elem_config:
                    subd["area_m2"] = user_elem_config["area_m2"]
                if "material_opaque_lookup" in user_elem_config:
                    subd["material_opaque_lookup"] = user_elem_config["material_opaque_lookup"]
                if "material_window_lookup" in user_elem_config:
                    subd["material_window_lookup"] = user_elem_config["material_window_lookup"]

            out_sub = dict(subd)  # Keep a copy that we will finalize

            # (B) pick R_value from its range
            r_val_rng = subd.get("R_value_range", None)
            r_val = pick_val(r_val_rng, strategy) if r_val_rng else None
            # (C) pick U_value from its range
            u_val_rng = subd.get("U_value_range", None)
            u_val = pick_val(u_val_rng, strategy) if u_val_rng else None

            # If user_config_fenez sets a fixed R_value or U_value, override
            if user_config_fenez and "elements" in user_config_fenez:
                user_elem_vals = user_config_fenez["elements"].get(elem_name, {})
                if "R_value" in user_elem_vals and user_elem_vals["R_value"] is not None:
                    r_val = user_elem_vals["R_value"]
                if "U_value" in user_elem_vals and user_elem_vals["U_value"] is not None:
                    u_val = user_elem_vals["U_value"]

            out_sub["R_value"] = r_val
            out_sub["U_value"] = u_val
            # also store "range_used" for clarity
            if r_val_rng:
                out_sub["R_value_range_used"] = r_val_rng
            if u_val_rng:
                out_sub["U_value_range_used"] = u_val_rng

            # (D) create sub-element material_opaque
            mat_opq_sub_key = subd.get("material_opaque_lookup", None)
            if mat_opq_sub_key and mat_opq_sub_key in material_lookup:
                out_sub["material_opaque"] = assign_material_from_lookup(
                    material_lookup[mat_opq_sub_key], strategy
                )
            else:
                out_sub["material_opaque"] = None

            # (E) create sub-element material_window
            mat_win_sub_key = subd.get("material_window_lookup", None)
            if mat_win_sub_key and mat_win_sub_key in material_lookup:
                out_sub["material_window"] = assign_material_from_lookup(
                    material_lookup[mat_win_sub_key], strategy
                )
            else:
                out_sub["material_window"] = None

            elements[elem_name] = out_sub

    # Build the result
    result = {
        "roughness": rough_str,
        "wwr_range_used": default_wwr_range,  # store the used range
        "wwr": wwr_val,
        "material_opaque": final_opq,
        "material_window": final_win,
        "elements": elements
    }

    # final step => enforce the R_value or U_value in the sub-element materials
    # i.e., if sub-element has R=2.5, we recalc thickness or conductivity for the opaque material
    for elem_name, elem_data in result["elements"].items():
        r_val = elem_data.get("R_value", None)
        u_val = elem_data.get("U_value", None)
        if r_val is None and u_val is not None and u_val != 0:
            r_val = 1.0 / u_val

        # override opaque
        mat_opq = elem_data.get("material_opaque", None)
        if mat_opq and r_val is not None:
            if mat_opq["obj_type"].upper() == "MATERIAL":
                thick = mat_opq["Thickness"]
                if r_val != 0:
                    mat_opq["Conductivity"] = thick / r_val
            elif mat_opq["obj_type"].upper() == "MATERIAL:NOMASS":
                mat_opq["Thermal_Resistance"] = r_val

        # override window
        mat_win = elem_data.get("material_window", None)
        if mat_win and u_val is not None and u_val != 0:
            if mat_win["obj_type"].upper() == "WINDOWMATERIAL:GLAZING":
                thick = mat_win["Thickness"]
                # approximate => conduction = U * thickness
                mat_win["Conductivity"] = u_val * thick

    return result

  --- File Contents End ---

  File: materials_lookup.py
  --- File Contents Start ---
# fenez/materials_lookup.py

"""
materials_lookup.py

Defines a dictionary 'material_lookup' where each key is a label like
"Concrete_200mm" or "Glazing_Clear_3mm". Each value is a dict containing:
  - obj_type (e.g. "MATERIAL", "MATERIAL:NOMASS", "WINDOWMATERIAL:GLAZING", etc.)
  - Name (the actual name in the IDF)
  - Roughness
  - Range-based fields like "Thickness_range", "Conductivity_range", etc.
  - Possibly optical properties for glazing, etc.
"""

material_lookup = {
    "N/A": {
        "obj_type": "MATERIAL",
        "Name": "Not_Applicable",
        "Description": "Placeholder for assemblies that have no relevant opaque or window material."
    },

    # -------------------------------------------------------------------
    #  OPAQUE MATERIALS
    # -------------------------------------------------------------------
    "Concrete_200mm": {
        "obj_type": "MATERIAL",
        "Name": "Concrete_200mm",
        "Roughness": "MediumRough",
        "Thickness_range": (0.195, 0.205),
        "Conductivity_range": (1.5, 1.7),
        "Density_range": (2250, 2350),
        "Specific_Heat_range": (850, 950),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "GroundContactFloor_Generic": {
        "obj_type": "MATERIAL",
        "Name": "GroundContactFloor_Generic",
        "Roughness": "MediumRough",
        "Thickness_range": (0.10, 0.12),
        "Conductivity_range": (1.0, 1.2),
        "Density_range": (2100, 2300),
        "Specific_Heat_range": (850, 900),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "InternalFloor_Generic": {
        "obj_type": "MATERIAL",
        "Name": "InternalFloor_Generic",
        "Roughness": "MediumSmooth",
        "Thickness_range": (0.12, 0.15),
        "Conductivity_range": (0.7, 1.2),
        "Density_range": (1800, 2000),
        "Specific_Heat_range": (800, 900),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "Insulated_Roof_R5": {
        "obj_type": "MATERIAL:NOMASS",
        "Name": "Insulated_Roof_R5",
        "Roughness": "MediumRough",
        # If your R-value range is 4â€“5, we model it as Thermal_Resistance_range
        "Thermal_Resistance_range": (4.0, 5.0),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "InteriorWall_Generic": {
        "obj_type": "MATERIAL",
        "Name": "InteriorWall_Generic",
        "Roughness": "MediumSmooth",
        "Thickness_range": (0.10, 0.15),
        "Conductivity_range": (0.4, 0.6),
        "Density_range": (700, 900),
        "Specific_Heat_range": (800, 1000),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "DoorPanel_Range": {
        "obj_type": "MATERIAL",
        "Name": "DoorPanel_Range",
        "Roughness": "MediumRough",
        "Thickness_range": (0.14, 0.25),
        "Conductivity_range": (1.4, 1.7),
        "Density_range": (600, 700),
        "Specific_Heat_range": (2200, 2400),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    # -------------------------------------------------------------------
    #  WINDOWS / GLAZING
    # -------------------------------------------------------------------
    "Glazing_Clear_3mm": {
        "obj_type": "WINDOWMATERIAL:GLAZING",
        "Name": "Glazing_Clear_3mm",
        "Optical_Data_Type": "SpectralAverage",
        "Thickness_range": (0.003, 0.003),
        "Solar_Transmittance_range": (0.76, 0.78),
        "Front_Solar_Reflectance_range": (0.07, 0.08),
        "Back_Solar_Reflectance_range": (0.07, 0.08),
        "Visible_Transmittance_range": (0.86, 0.88),
        "Front_Visible_Reflectance_range": (0.06, 0.07),
        "Back_Visible_Reflectance_range": (0.06, 0.07),
        "IR_Transmittance": 0.0,
        "Front_IR_Emissivity_range": (0.84, 0.84),
        "Back_IR_Emissivity_range": (0.84, 0.84),
        "Conductivity_range": (0.95, 1.05),
        "Dirt_Correction_Factor_range": (1.0, 1.0),
        "Solar_Diffusing": "No"
    },

    "Glazing_Clear_3mm_Post": {
        "obj_type": "WINDOWMATERIAL:GLAZING",
        "Name": "Glazing_Clear_3mm_Post",
        "Optical_Data_Type": "SpectralAverage",
        "Thickness_range": (0.003, 0.003),
        "Solar_Transmittance_range": (0.75, 0.75),
        "Front_Solar_Reflectance_range": (0.07, 0.07),
        "Back_Solar_Reflectance_range": (0.07, 0.07),
        "Visible_Transmittance_range": (0.85, 0.85),
        "Front_Visible_Reflectance_range": (0.07, 0.07),
        "Back_Visible_Reflectance_range": (0.07, 0.07),
        "IR_Transmittance": 0.0,
        "Front_IR_Emissivity_range": (0.84, 0.84),
        "Back_IR_Emissivity_range": (0.84, 0.84),
        "Conductivity_range": (1.0, 1.0),
        "Dirt_Correction_Factor_range": (1.0, 1.0),
        "Solar_Diffusing": "No"
    },

    # -------------------------------------------------------------------
    #  OPTIONAL / LEGACY ENTRIES
    # -------------------------------------------------------------------
    "DoorPanel_Range2": {
        "obj_type": "MATERIAL",
        "Name": "DoorPanel_Range2",
        "Roughness": "MediumSmooth",
        "Thickness_range": (0.04, 0.05),
        "Conductivity_range": (0.4, 0.5),
        "Density_range": (600, 700),
        "Specific_Heat_range": (1200, 1300),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "Ceiling_Insulation_R3": {
        "obj_type": "MATERIAL",
        "Name": "Ceiling_Insulation_R3",
        "Roughness": "MediumRough",
        "Thickness_range": (0.02, 0.03),
        "Conductivity_range": (0.035, 0.045),
        "Density_range": (20, 25),
        "Specific_Heat_range": (1400, 1500),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "Roof_Insulation_R5": {
        "obj_type": "MATERIAL",
        "Name": "Roof_Insulation_R5",
        "Roughness": "MediumRough",
        "Thickness_range": (0.04, 0.05),
        "Conductivity_range": (0.03, 0.04),
        "Density_range": (25, 30),
        "Specific_Heat_range": (1400, 1500),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    },

    "AdiabaticWall_Generic": {
        "obj_type": "MATERIAL",
        "Name": "AdiabaticWall_Generic",
        "Roughness": "MediumSmooth",
        "Thickness_range": (0.15, 0.20),
        "Conductivity_range": (0.30, 0.40),
        "Density_range": (200, 300),
        "Specific_Heat_range": (1000, 1100),
        "Thermal_Absorptance_range": (0.9, 0.9),
        "Solar_Absorptance_range": (0.7, 0.7),
        "Visible_Absorptance_range": (0.7, 0.7)
    }
}





""""


('Two-and-a-half-story House', '1946-1964', 'scenario1', 'pre_calibration'): {
    "roughness": "MediumRough",
    "wwr_range": (0.2, 0.25),
    "material_opaque_lookup": "Concrete_200mm",  # fallback for exterior walls
    "material_window_lookup": "Glazing_Clear_3mm",

    # 1) Exterior walls
    "exterior_wall": {
        "area_m2": 70.0,
        "R_value_range": (0.5, 1.0),
        "U_value_range": (1.0, 2.0),
        "material_opaque_lookup": "Concrete_200mm"
    },

    # 2) Ground floor
    "ground_floor": {
        "area_m2": 40.0,
        "R_value_range": (1.0, 1.5),
        "U_value_range": (0.7, 1.0),
        "material_opaque_lookup": "GroundContactFloor_Generic"
    },

    # 3) Intermediate floor (between stories)
    "inter_floor": {
        "area_m2": 40.0,
        "R_value_range": (0.6, 1.0),
        "U_value_range": (1.0, 1.7),
        "material_opaque_lookup": "InternalFloor_Generic"
    },

    # 4) Roof
    "flat_roof": {
        "area_m2": 30.0,
        "R_value_range": (4.0, 5.0),
        "U_value_range": (0.2, 0.25),
        "material_opaque_lookup": "Insulated_Roof_R5"
    },

    # 5) Interior walls
    "interior_wall": {
        "area_m2": 60.0,
        "R_value_range": (0.5, 0.8),
        "U_value_range": (1.25, 2.0),
        "material_opaque_lookup": "InteriorWall_Generic"
    },

    # Doors & windows
    "doors": {
        "area_m2": 4.0,
        "R_value_range": (None, None),
        "U_value_range": (3.4, 3.4),
        "material_opaque_lookup": "DoorPanel_Range"
    },
    "windows": {
        "area_m2": 10.0,
        "R_value_range": (None, None),
        "U_value_range": (1.4, 2.9),
        "material_window_lookup": "Glazing_Clear_3mm"
    }
}


"""	
  --- File Contents End ---

================================================================================

Folder: D:\Documents\E_Plus_2030_py\idf_objects\fenez\__pycache__

================================================================================

