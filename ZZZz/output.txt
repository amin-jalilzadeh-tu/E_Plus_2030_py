Folder: D:\Documents\E_Plus_2030_py\ventilation

  File: add_ventilation.py
  --- File Contents Start ---
# ventilation/add_ventilation.py

from ventilation.assign_ventilation_values import assign_ventilation_params_with_overrides
from ventilation.schedules import (
    create_always_on_schedule,
    create_day_night_schedule,
    create_workhours_schedule
)
from ventilation.create_ventilation_systems import create_ventilation_system
from ventilation.calc_functions import calc_infiltration, calc_required_ventilation_flow
from ventilation.mappings import (
    safe_lower,
    map_age_range_to_year_key,
    map_infiltration_key,
    map_usage_key
)

def add_ventilation_to_idf(
    idf,
    building_row,
    calibration_stage="pre_calibration",
    strategy="A",            # "A" => pick midpoint, "B" => random, "C" => pick min, etc.
    random_seed=None,
    user_config_vent=None,
    assigned_vent_log=None
):
    """
    Adds infiltration + ventilation to the IDF based on building_row data,
    referencing infiltration base/year_factor/system_type from our override-based function.
    Then, if system_type == "D", sets hrv_eff on the existing IdealLoads objects.
    """

    # 1) Ensure key schedules exist (the default ones)
    if not idf.getobject("SCHEDULE:CONSTANT", "AlwaysOnSched"):
        create_always_on_schedule(idf, "AlwaysOnSched")
    if not idf.getobject("SCHEDULE:COMPACT", "VentSched_DayNight"):
        create_day_night_schedule(idf, "VentSched_DayNight")
    if not idf.getobject("SCHEDULE:COMPACT", "WorkHoursSched"):
        create_workhours_schedule(idf, "WorkHoursSched")

    # 2) Extract building data
    bldg_id = building_row.get("ogc_fid", 0)
    bldg_func = safe_lower(building_row.get("building_function", "residential"))
    if bldg_func not in ("residential", "non_residential"):
        bldg_func = "residential"

    age_range_str = building_row.get("age_range", "2015 and later")
    year_key = map_age_range_to_year_key(age_range_str)

    infiltration_key = map_infiltration_key(building_row)
    usage_key = map_usage_key(building_row)

    is_res = (bldg_func == "residential")
    floor_area_m2 = building_row.get("area", 100.0)
    scenario = building_row.get("scenario", "scenario1")

    # 3) Assign infiltration & ventilation parameters (including schedules) via override function
    assigned_vent = assign_ventilation_params_with_overrides(
        building_id=bldg_id,
        building_function=bldg_func,
        age_range=age_range_str,
        scenario=scenario,
        calibration_stage=calibration_stage,
        strategy=strategy,
        random_seed=random_seed,
        user_config_vent=user_config_vent,
        assigned_vent_log=assigned_vent_log,
        infiltration_key=infiltration_key,
        year_key=year_key,
        is_residential=is_res,
        default_flow_exponent=0.67
    )

    # Extract the assigned infiltration/vent params
    infiltration_base = assigned_vent["infiltration_base"]
    year_factor       = assigned_vent["year_factor"]
    system_type       = assigned_vent["system_type"]
    f_ctrl_val        = assigned_vent["f_ctrl"]
    fan_pressure      = assigned_vent["fan_pressure"]
    hrv_eff           = assigned_vent["hrv_eff"]

    # (NEW) Extract infiltration/ventilation schedule names (fallback if missing)
    infiltration_sched = assigned_vent.get("infiltration_schedule_name", "AlwaysOnSched")
    ventilation_sched  = assigned_vent.get("ventilation_schedule_name",  "VentSched_DayNight")

    print(
        f"[VENT OVERRIDES] For bldg_id={bldg_id}, infiltration={infiltration_base}, "
        f"year_factor={year_factor}, sys={system_type}, fanP={fan_pressure}, hrv_eff={hrv_eff}"
    )

    # 4) Calculate total infiltration flow (m³/s)
    infiltration_m3_s_total = calc_infiltration(
        infiltration_base=infiltration_base,
        year_factor=year_factor,
        flow_exponent=0.67,
        floor_area_m2=floor_area_m2
    )

    # 5) Calculate total ventilation flow (m³/s)
    vent_flow_m3_s_total = calc_required_ventilation_flow(
        building_function=bldg_func,
        f_ctrl_val=f_ctrl_val,
        floor_area_m2=floor_area_m2,
        usage_key=usage_key
    )

    # 6) Distribute flows to zones
    zones = idf.idfobjects["ZONE"]
    if not zones:
        print("[VENT] No zones found, skipping.")
        return

    n_zones = len(zones)
    infiltration_per_zone = infiltration_m3_s_total / n_zones
    vent_per_zone = vent_flow_m3_s_total / n_zones

    print(
        f"[VENTILATION] Bldg {bldg_id}, sys={system_type}, "
        f"infiltration={infiltration_m3_s_total:.3f}, vent={vent_flow_m3_s_total:.3f}"
    )

    # 7) Create infiltration & ventilation objects per zone
    for zone_obj in zones:
        zone_name = zone_obj.Name

        # system_type + pick_strategy chosen from assigned_vent
        # infiltration_sched_name & ventilation_sched_name come from assigned_vent
        iobj, vobj = create_ventilation_system(
            idf,
            building_function=bldg_func,
            system_type=system_type,
            zone_name=zone_name,
            infiltration_m3_s=infiltration_per_zone,
            vent_flow_m3_s=vent_per_zone,
            infiltration_sched_name=infiltration_sched,
            ventilation_sched_name=ventilation_sched,
            pick_strategy="random" if strategy == "B" else "midpoint"
        )

        print(
            f"   => {zone_name} infiltration={infiltration_per_zone:.4f} "
            f"vent={vent_per_zone:.4f}"
        )

    # 8) If system_type == "D", set HRV effectiveness on IdealLoads
    if system_type == "D" and hrv_eff > 0.0:
        for zone_obj in zones:
            zone_name = zone_obj.Name
            ideal_name = f"{zone_name} Ideal Loads"
            ideal_obj = idf.getobject("ZONEHVAC:IDEALLOADSAIRSYSTEM", ideal_name)
            if ideal_obj:
                # If the IDD fields exist, set them (E+ >=9.0 field name).
                if hasattr(ideal_obj, "Sensible_Heat_Recovery_Effectiveness"):
                    ideal_obj.Sensible_Heat_Recovery_Effectiveness = hrv_eff
                    print(f"   => {ideal_name} HRV eff set to {hrv_eff:.3f}")

                # Example: if you also want to set Latent:
                # if hasattr(ideal_obj, "Latent_Heat_Recovery_Effectiveness"):
                #     ideal_obj.Latent_Heat_Recovery_Effectiveness = 0.0
            else:
                print(f"[VENT WARNING] {zone_name} Ideal Loads not found for system D. Skipping HRV eff.")

    return

  --- File Contents End ---

  File: assign_ventilation_values.py
  --- File Contents Start ---
# ventilation/assign_ventilation_values.py


import random
from .ventilation_lookup import ventilation_lookup

def find_vent_overrides(
    building_id,
    building_function,
    age_range,
    scenario,
    calibration_stage,
    user_config
):
    """
    Return user_config rows that match building_id, building_function, age_range, scenario, calibration_stage.
    """
    matches = []
    if user_config:
        for row in user_config:
            # building_id match
            if "building_id" in row and row["building_id"] != building_id:
                continue
            # building_function match
            if "building_function" in row and row["building_function"] != building_function:
                continue
            # age_range match
            if "age_range" in row and row["age_range"] != age_range:
                continue
            # scenario match
            if "scenario" in row and row["scenario"] != scenario:
                continue
            # calibration_stage match
            if "calibration_stage" in row and row["calibration_stage"] != calibration_stage:
                continue

            matches.append(row)
    return matches


def pick_val_with_range(
    rng_tuple,
    strategy="A",
    log_dict=None,
    param_name=None
):
    """
    rng_tuple = (min_val, max_val) or None.
    strategy  = "A"=>midpoint, "B"=>random, "C"=>min, etc.
    log_dict  => the assigned_vent_log[bldg_id] dictionary for storing range and final value.
    param_name=> e.g. "infiltration_base", "fan_pressure", "year_factor", etc.

    We store:
      log_dict[f"{param_name}_range"] = (min_val, max_val)
      log_dict[param_name]            = final_chosen_value
    """
    if rng_tuple is None:
        # fallback => just return 0
        chosen = 0.0
        return chosen

    min_v, max_v = rng_tuple

    # pick final
    if strategy == "A":
        chosen = (min_v + max_v) / 2.0
    elif strategy == "B":
        chosen = random.uniform(min_v, max_v)
    else:
        # fallback => pick min
        chosen = min_v

    if log_dict is not None and param_name:
        # store the numeric range
        log_dict[f"{param_name}_range"] = (min_v, max_v)
        # store the final
        log_dict[param_name] = chosen

    return chosen


def assign_ventilation_params_with_overrides(
    building_id=None,
    building_function="residential",
    age_range="2015 and later",
    scenario="scenario1",
    calibration_stage="pre_calibration",
    strategy="A",
    random_seed=None,
    user_config_vent=None,     # possibly a list of override rows
    assigned_vent_log=None,    # dictionary to store final picks
    # existing arguments from original code:
    infiltration_key=None,     # e.g. "A_corner"
    year_key=None,             # e.g. "1970-1992"
    is_residential=True,
    default_flow_exponent=0.67
):
    """
    Return a dict => {
       "infiltration_base": float,
       "year_factor": float,
       "system_type": str,
       "f_ctrl": float,
       "fan_pressure": float,
       "hrv_eff": float,
       "infiltration_schedule_name": str,
       "ventilation_schedule_name": str
    }

    Steps:
      1) fallback if calibration_stage not in ventilation_lookup => "pre_calibration".
      2) gather default infiltration_base range from infiltration_key (res or non_res).
      3) gather year_factor range from year_key
      4) pick default system_type => "A" (res) or "D" (non_res), or can be user-overridden.
      5) gather fan_pressure_range => can be user-overridden
      6) gather system_control_range => f_ctrl => can be user-overridden
      7) gather hrv_sensible_eff_range => if system_type=="D"
      8) apply user overrides from user_config_vent => override numeric ranges or system_type
      9) pick final infiltration_base, year_factor, fan_pressure, f_ctrl, hrv_eff with pick_val_with_range
      10) store infiltration_schedule_name, ventilation_schedule_name (strings)
      11) return assigned dict
    """

    # optional random seed
    if random_seed is not None:
        random.seed(random_seed)

    # 1) fallback

    if scenario not in ventilation_lookup:
        scenario = "scenario1"


    if calibration_stage not in ventilation_lookup:
        calibration_stage = "pre_calibration"
    stage_dict = ventilation_lookup[scenario][calibration_stage]

    # if assigned_vent_log => ensure we have a sub-dict for building_id
    if assigned_vent_log is not None and building_id not in assigned_vent_log:
        assigned_vent_log[building_id] = {}
    # local reference to store picks
    log_dict = assigned_vent_log[building_id] if (assigned_vent_log and building_id is not None) else None

    # 2) infiltration_base range
    if is_residential:
        # gather from stage_dict["residential_infiltration_range"]
        res_infil = stage_dict["residential_infiltration_range"]
        infiltration_base_rng = res_infil.get(infiltration_key, (1.0, 1.0))
        # also the system_control_range for res
        sys_ctrl_ranges = stage_dict["system_control_range_res"]
    else:
        # non_res_infiltration_range
        nonres_infil = stage_dict["non_res_infiltration_range"]
        infiltration_base_rng = nonres_infil.get(infiltration_key, (0.5, 0.5))
        sys_ctrl_ranges = stage_dict["system_control_range_nonres"]

    # 3) year_factor range
    year_factor_dict = stage_dict["year_factor_range"]
    year_factor_rng = year_factor_dict.get(year_key, (1.0, 1.0))

    # default system_type => "A" if residential, else "D"
    default_sys = "A" if is_residential else "D"

    # fan_pressure => often stored in stage_dict["fan_pressure_range"],
    # but it's not subdivided by infiltration_key. Let's skip or do (0,0) fallback
    fan_press_rng = (0.0, 0.0)
    if "fan_pressure_range" in stage_dict:
        # Possibly you have "fan_pressure_range":{"res_mech":(40,60),"nonres_intake":(90,110),...}
        # but we do not know which subkey to pick. You can adapt if needed.
        # We'll skip for brevity, or we can do a direct approach:
        # fan_press_rng = stage_dict["fan_pressure_range"].get("res_mech",(0.0,0.0))
        pass

    # 6) f_ctrl => pick from system_control_range
    # default to sys_ctrl_ranges["A"]["f_ctrl_range"] if system_type is "A", etc.
    # but we won't finalize until after user overrides.
    system_type_final = default_sys  # can be changed
    if system_type_final in sys_ctrl_ranges:
        f_ctrl_rng = sys_ctrl_ranges[system_type_final].get("f_ctrl_range", (1.0,1.0))
    else:
        f_ctrl_rng = (1.0,1.0)

    # 7) HRV => stage_dict["hrv_sensible_eff_range"]
    hrv_eff_rng = (0.0, 0.0)
    if "hrv_sensible_eff_range" in stage_dict:
        hrv_eff_rng = stage_dict["hrv_sensible_eff_range"]

    # 8) user overrides
    matches = find_vent_overrides(
        building_id or 0,
        building_function or "residential",
        age_range or "2015 and later",
        scenario or "scenario1",
        calibration_stage,
        user_config_vent
    )

    def override_range(current_range, row):
        if "fixed_value" in row:
            val = row["fixed_value"]
            return (val, val)
        elif "min_val" in row and "max_val" in row:
            return (row["min_val"], row["max_val"])
        return current_range

    for row in matches:
        pname = row.get("param_name","")
        if pname == "infiltration_base":
            infiltration_base_rng = override_range(infiltration_base_rng, row)
        elif pname == "year_factor":
            year_factor_rng = override_range(year_factor_rng, row)
        elif pname == "system_type":
            if "fixed_value" in row:
                system_type_final = row["fixed_value"]
        elif pname == "fan_pressure":
            fan_press_rng = override_range(fan_press_rng, row)
        elif pname == "f_ctrl":
            f_ctrl_rng = override_range(f_ctrl_rng, row)
        elif pname == "hrv_eff":
            hrv_eff_rng = override_range(hrv_eff_rng, row)
        # If you had infiltration_schedule, ventilation_schedule overrides, you could read them here:
        # e.g. if pname=="infiltration_schedule_name": infiltration_sched_name = row["fixed_value"]

    # 9) now pick final infiltration_base, year_factor, fan_pressure, f_ctrl, hrv_eff
    infiltration_base_val = pick_val_with_range(infiltration_base_rng, strategy, log_dict, "infiltration_base")
    year_factor_val       = pick_val_with_range(year_factor_rng,       strategy, log_dict, "year_factor")
    fan_pressure_val      = pick_val_with_range(fan_press_rng,         strategy, log_dict, "fan_pressure")
    f_ctrl_val            = pick_val_with_range(f_ctrl_rng,            strategy, log_dict, "f_ctrl")

    hrv_eff_val = 0.0
    if system_type_final == "D":  # if user or default => system_type="D"
        # pick from hrv_eff_rng
        hrv_eff_val = pick_val_with_range(hrv_eff_rng, strategy, log_dict, "hrv_eff")

    # 10) infiltration/vent schedules => store them if you want
    # We default them to "AlwaysOnSched"/"VentSched_DayNight", or
    # they could be user-overridden above if param_name was "infiltration_schedule_name", etc.
    infiltration_sched_name = "AlwaysOnSched"
    ventilation_sched_name  = "VentSched_DayNight"

    # if we want them in the log:
    if log_dict is not None:
        log_dict["infiltration_schedule_name"] = infiltration_sched_name
        log_dict["ventilation_schedule_name"]  = ventilation_sched_name

    # 11) build final assigned dict
    assigned = {
        "infiltration_base": infiltration_base_val,
        "year_factor": year_factor_val,
        "system_type": system_type_final,
        "f_ctrl": f_ctrl_val,
        "fan_pressure": fan_pressure_val,
        "hrv_eff": hrv_eff_val,
        "infiltration_schedule_name": infiltration_sched_name,
        "ventilation_schedule_name": ventilation_sched_name
    }

    return assigned




    """
    Searches a user_config list/dict for any override entries matching the
    building_id, building_function, age_range, scenario, and calibration_stage.
    Returns a list of matching dict rows.

    Each 'row' in user_config can specify:
      - "building_id"
      - "building_function"
      - "age_range"
      - "scenario"
      - "calibration_stage"
      - plus override fields for infiltration_base, year_factor, system_type, fan_pressure, f_ctrl, hrv_eff, etc.

    If any of those fields are present in the row and do not match the
    current building, that row is skipped. Otherwise, the row is considered
    a match and is returned in the list.
    """

    """
    Return a dict with infiltration_base, year_factor, system_type, f_ctrl, fan_pressure,
    hrv_eff, infiltration_schedule_name, ventilation_schedule_name, etc.

    This function uses:
      1) The scenario & calibration_stage to locate a sub-dict in 'ventilation_lookup'
      2) The infiltration_key/year_key to get infiltration & year_factor ranges
      3) user_config_vent overrides to optionally override any of the above
      4) A picking strategy (A=midpoint, B=uniform random, C=lower bound) for final selection
      5) The building_function & usage_key to also fetch schedule_info from 'ventilation_lookup'
         => infiltration_schedule_name & ventilation_schedule_name

    Then logs final picks into assigned_vent_log if provided (dict-based log).
    """


  --- File Contents End ---

  File: calc_functions.py
  --- File Contents Start ---
# ventilation/calc_functions.py

import math

def calc_infiltration(
    infiltration_base,  # e.g. assigned["infiltration_base"] from assign_ventilation_values
    year_factor,        # assigned["year_factor"] from overrides
    flow_exponent,      # typically 0.67 (standard infiltration exponent)
    floor_area_m2       # total building area
):
    """
    Calculate infiltration in m3/s based on an 'infiltration_base' at 10 Pa.

    Steps:
      1) Multiply infiltration_base by year_factor => qv10_lea_ref (represents
         infiltration at 10 Pa for the building, e.g. in dm3/s·m2 or similar).
      2) Convert qv10 => qv1 by applying exponent:
            qv1 = qv10 * (1/10)^n
         (n = flow_exponent, e.g. 0.67 per NTA 8800).
      3) Multiply qv1_lea_ref_per_m2_h by total floor area => infiltration_m3/h.
      4) Convert infiltration_m3/h => infiltration_m3/s by dividing by 3600.

    NTA 8800 basis:
      - Table 11.2 prescribes n=0.67 for leak losses (infiltration).
      - Section 11.2.5 references how infiltration is often reported at 10 Pa
        and needs converting to 1 Pa. This code parallels that approach.

    Returns infiltration in m3/s.
    """

    # 1) infiltration_base * year_factor => infiltration at 10 Pa
    qv10_lea_ref = infiltration_base * year_factor

    # 2) Convert from qv10 to qv1 by (1/10)^exponent
    qv1_lea_ref_per_m2_h = qv10_lea_ref * (1.0 / 10.0)**flow_exponent

    # 3) Multiply by floor area => infiltration in m3/h
    infiltration_m3_h = qv1_lea_ref_per_m2_h * floor_area_m2

    # 4) Convert from m3/h => m3/s
    infiltration_m3_s = infiltration_m3_h / 3600.0
    return infiltration_m3_s


def calc_required_ventilation_flow(
    building_function,
    f_ctrl_val,
    floor_area_m2,
    usage_key=None
):
    """
    Calculate the required ventilation flow (m3/s).

    Approach:
      - If residential: 0.9 dm3/s/m2 is used as base, then multiplied by
        control factor (f_ctrl_val). A minimum of ~126 m3/h is enforced.
        => 126 m3/h = 35 L/s, typical minimal design flow for dwellings.

      - If non-residential: usage_key (office_area_based, childcare, retail, etc.)
        references typical design flows (dm3/s/m2). Then multiplied by f_ctrl_val.

    NTA 8800 basis:
      - In Section 11.2.2.5 or Table 11.8, typical air supply rates are given
        for various functions. This code uses simplified example values.

    Returns flow in m3/s.
    """

    if building_function == "residential":
        # base usage flow in dm3/s
        qv_uspec = 0.9
        # multiply by floor area => dm3/s
        qv_oda_req_des_dm3_s = qv_uspec * floor_area_m2
        # convert to m3/h
        qv_oda_req_des_m3_h = qv_oda_req_des_dm3_s * 3.6

        # apply control factor
        qv_oda_req_m3_h = f_ctrl_val * qv_oda_req_des_m3_h

        # enforce minimum ~126 m3/h
        if qv_oda_req_m3_h < 126:
            qv_oda_req_m3_h = 126

        # return m3/s
        return qv_oda_req_m3_h / 3600.0

    else:
        # non-res => usage_key references typical design rates
        usage_flow_map = {
            "office_area_based": 1.0,  # dm3/s per m2
            "childcare": 4.8,
            "retail": 0.6
        }
        qv_usage = usage_flow_map.get(usage_key, 1.0)  # fallback 1.0 dm3/s/m2
        qv_oda_req_des_dm3_s = qv_usage * floor_area_m2
        qv_oda_req_des_m3_h  = qv_oda_req_des_dm3_s * 3.6

        # apply control factor
        qv_oda_req_m3_h = f_ctrl_val * qv_oda_req_des_m3_h
        return qv_oda_req_m3_h / 3600.0


def calc_fan_power(fan_pressure, fan_efficiency, flow_m3_s):
    """
    Compute fan power in W:
      P_fan = (fan_pressure * flow_m3_s) / fan_efficiency

    NTA 8800 doesn't provide a direct formula for fan power in W in exactly
    these terms, but this approach is standard fluid power:
       Pressure (Pa) * Volumetric Flow (m3/s) = Power in J/s (Watts),
       then / efficiency to account for fan energy losses.

    fan_pressure: Pa
    flow_m3_s: m3/s
    fan_efficiency: fraction (0.0 < eff <= 1.0)
    returns: fan power in Watts
    """
    if fan_efficiency <= 0:
        fan_efficiency = 0.7
    return (fan_pressure * flow_m3_s) / fan_efficiency

  --- File Contents End ---

  File: config_systems.py
  --- File Contents Start ---
# ventilation/config_systems.py

"""
Defines a dictionary SYSTEMS_CONFIG with separate entries for:
  - building_function: "residential" vs. "non_residential"
  - system_type:       "A", "B", "C", or "D"

Each system entry has:
  1) "description"                => short text label
  2) "ventilation_object_type"    => e.g. 'ZONEVENTILATION:DESIGNFLOWRATE'
  3) "ventilation_type_options"   => a list of possible Ventilation_Type strings
  4) "range_params"               => dictionary of numeric fields that are stored as (min, max) ranges
  5) "use_ideal_loads"            => boolean (True if system D uses IdealLoads, etc.)

Later, in your `create_ventilation_systems.py`, you can pick or compute final single values:
  - either pick a random or midpoint from "Fan_Pressure_Rise" range
  - or pick one of the "ventilation_type_options", etc.
"""

SYSTEMS_CONFIG = {
    "residential": {
        # -----------------------------------------------------------
        # System A
        # -----------------------------------------------------------
        "A": {
            "description": "Natural supply + Natural exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Natural"  # Could allow more, e.g. "Intake", "Exhaust" if you want
            ],
            "range_params": {
                # If you want a zero fan pressure for natural, but let's keep an example range
                "Fan_Pressure_Rise": (0.0, 0.0),
                "Fan_Total_Efficiency": (0.6, 0.8)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System B
        # -----------------------------------------------------------
        "B": {
            "description": "Mechanical supply + Natural infiltration",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Intake"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (40.0, 60.0),
                "Fan_Total_Efficiency": (0.65, 0.75)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System C
        # -----------------------------------------------------------
        "C": {
            "description": "Natural supply + Mechanical exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Exhaust"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (40.0, 60.0),
                "Fan_Total_Efficiency": (0.65, 0.75)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System D
        # -----------------------------------------------------------
        "D": {
            "description": "Balanced mechanical (supply + exhaust), with HRV",
            "ventilation_object_type": "ZONEHVAC:IDEALLOADSAIRSYSTEM",
            "ventilation_type_options": [
                "Balanced"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (50.0, 80.0),
                "Fan_Total_Efficiency": (0.7, 0.85),
                # Example for HRV fields if you want them here:
                "Sensible_Heat_Recovery_Effectiveness": (0.70, 0.80),
                "Latent_Heat_Recovery_Effectiveness": (0.0, 0.0)
            },
            "use_ideal_loads": True
        }
    },

    "non_residential": {
        # -----------------------------------------------------------
        # System A
        # -----------------------------------------------------------
        "A": {
            "description": "Natural supply + Natural exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Natural"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (0.0, 0.0),
                "Fan_Total_Efficiency": (0.5, 0.6)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System B
        # -----------------------------------------------------------
        "B": {
            "description": "Mechanical supply + Natural exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Intake"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (90.0, 110.0),
                "Fan_Total_Efficiency": (0.65, 0.75)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System C
        # -----------------------------------------------------------
        "C": {
            "description": "Natural supply + Mechanical exhaust",
            "ventilation_object_type": "ZONEVENTILATION:DESIGNFLOWRATE",
            "ventilation_type_options": [
                "Exhaust"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (140.0, 160.0),
                "Fan_Total_Efficiency": (0.70, 0.80)
            },
            "use_ideal_loads": False
        },

        # -----------------------------------------------------------
        # System D
        # -----------------------------------------------------------
        "D": {
            "description": "Balanced mechanical supply & exhaust (with optional HRV)",
            "ventilation_object_type": "ZONEHVAC:IDEALLOADSAIRSYSTEM",
            "ventilation_type_options": [
                "Balanced"
            ],
            "range_params": {
                "Fan_Pressure_Rise": (100.0, 120.0),
                "Fan_Total_Efficiency": (0.65, 0.80),
                "Sensible_Heat_Recovery_Effectiveness": (0.75, 0.85),
                "Latent_Heat_Recovery_Effectiveness": (0.0, 0.0)
            },
            "use_ideal_loads": True
        }
    }
}

  --- File Contents End ---

  File: create_ventilation_systems.py
  --- File Contents Start ---
# ventilation/create_ventilation_systems.py

import random
from ventilation.config_systems import SYSTEMS_CONFIG

def create_ventilation_system(
    idf,
    building_function,      # 'residential' or 'non_residential'
    system_type,            # 'A', 'B', 'C', or 'D'
    zone_name,
    infiltration_m3_s,
    vent_flow_m3_s,
    infiltration_sched_name="AlwaysOnSched",
    ventilation_sched_name="VentSched_DayNight",
    pick_strategy="midpoint"  # or "random"
):
    """
    Creates two objects for the zone:
      1) A ZONEINFILTRATION:DESIGNFLOWRATE object (always).
      2) Depending on system_type:
         - A/B/C => a ZONEVENTILATION:DESIGNFLOWRATE object
         - D     => modifies an existing ZONEHVAC:IDEALLOADSAIRSYSTEM
                    (already added by add_HVAC_Ideal_to_all_zones, if used)

    Returns (infiltration_obj, vent_obj_or_ideal_obj).
    """

    # -------------------------------------------------------
    # 1) Grab the config for this system
    # -------------------------------------------------------
    if building_function not in SYSTEMS_CONFIG:
        building_function = "residential"
    if system_type not in SYSTEMS_CONFIG[building_function]:
        system_type = "A"

    config = SYSTEMS_CONFIG[building_function][system_type]

    # -------------------------------------------------------
    # 2) Helper to pick a single value from a (min, max) range
    # -------------------------------------------------------
    def pick_val(rng):
        """
        rng is (min_val, max_val).
        pick_strategy == 'midpoint' => return average
        pick_strategy == 'random'   => return random.uniform(...)
        """
        if pick_strategy == "random":
            return random.uniform(rng[0], rng[1])
        else:
            # default => midpoint
            return (rng[0] + rng[1]) / 2.0

    # -------------------------------------------------------
    # 3) Create infiltration object (ZONEINFILTRATION:DESIGNFLOWRATE)
    # -------------------------------------------------------
    iobj = idf.newidfobject("ZONEINFILTRATION:DESIGNFLOWRATE")
    iobj.Name = f"Infil_{building_function}_{system_type}_{zone_name}"

    # Some E+ versions use .Zone_or_ZoneList_or_Space_or_SpaceList_Name
    # others use .Zone_or_ZoneList_Name
    if hasattr(iobj, "Zone_or_ZoneList_or_Space_or_SpaceList_Name"):
        iobj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zone_name
    else:
        iobj.Zone_or_ZoneList_Name = zone_name

    # Assign infiltration schedule and flow
    iobj.Schedule_Name = infiltration_sched_name
    iobj.Design_Flow_Rate_Calculation_Method = "Flow/Zone"
    iobj.Design_Flow_Rate = infiltration_m3_s

    # -------------------------------------------------------
    # 4) Prepare final param values from config["range_params"]
    #    e.g. fan pressure, heat recovery, etc.
    # -------------------------------------------------------
    chosen_params = {}
    range_dict = config.get("range_params", {})
    for param_name, rng in range_dict.items():
        chosen_val = pick_val(rng)
        chosen_params[param_name] = chosen_val

    # Choose from the ventilation_type_options if present
    ventilation_type_list = config.get("ventilation_type_options", [])
    if ventilation_type_list:
        chosen_vent_type = random.choice(ventilation_type_list)
    else:
        chosen_vent_type = "Natural"  # fallback if none provided

    # -------------------------------------------------------
    # 5) If system D => update an existing IdealLoads object
    #    else => create a ZONEVENTILATION:DESIGNFLOWRATE
    # -------------------------------------------------------
    if config["use_ideal_loads"]:
        # System D => Balanced mechanical => find the existing IdealLoads object
        ideal_name = f"{zone_name} Ideal Loads"
        ideal_obj = idf.getobject("ZONEHVAC:IDEALLOADSAIRSYSTEM", ideal_name)

        if ideal_obj:
            # Example: set fields in the IdealLoads that exist in chosen_params
            # e.g. if param_name == "Sensible_Heat_Recovery_Effectiveness"
            for param_field, final_val in chosen_params.items():
                # We must confirm the IDD field name matches param_field
                if hasattr(ideal_obj, param_field):
                    setattr(ideal_obj, param_field, final_val)

            # If desired, you could limit the air flow to 'vent_flow_m3_s' here:
            #   ideal_obj.Heating_Limit = "LimitFlowRate"
            #   ideal_obj.Maximum_Heating_Air_Flow_Rate = vent_flow_m3_s
            #   ideal_obj.Cooling_Limit = "LimitFlowRate"
            #   ideal_obj.Maximum_Cooling_Air_Flow_Rate = vent_flow_m3_s

            return iobj, ideal_obj
        else:
            print(f"[VENT WARNING] {zone_name} Ideal Loads not found; system D creation skipped.")
            return iobj, None

    else:
        # Systems A, B, C => create a ZONEVENTILATION:DESIGNFLOWRATE
        vobj = idf.newidfobject(config["ventilation_object_type"])
        vobj.Name = f"Vent_{building_function}_{system_type}_{zone_name}"
        if hasattr(vobj, "Zone_or_ZoneList_or_Space_or_SpaceList_Name"):
            vobj.Zone_or_ZoneList_or_Space_or_SpaceList_Name = zone_name
        else:
            vobj.Zone_or_ZoneList_Name = zone_name

        # Assign the chosen (or default) ventilation schedule and flow
        vobj.Schedule_Name = ventilation_sched_name
        vobj.Design_Flow_Rate_Calculation_Method = "Flow/Zone"
        vobj.Design_Flow_Rate = vent_flow_m3_s

        # Insert system-specific fields if they exist in the object
        if hasattr(vobj, "Ventilation_Type"):
            vobj.Ventilation_Type = chosen_vent_type

        if hasattr(vobj, "Fan_Pressure_Rise") and "Fan_Pressure_Rise" in chosen_params:
            vobj.Fan_Pressure_Rise = chosen_params["Fan_Pressure_Rise"]

        if hasattr(vobj, "Fan_Total_Efficiency") and "Fan_Total_Efficiency" in chosen_params:
            vobj.Fan_Total_Efficiency = chosen_params["Fan_Total_Efficiency"]

        return iobj, vobj

  --- File Contents End ---

  File: mappings.py
  --- File Contents Start ---
# ventilation/mappings.py

def safe_lower(val):
    """Helper to safely lowercase a string."""
    if isinstance(val, str):
        return val.lower()
    return ""

def map_age_range_to_year_key(age_range_str):
    """
    Convert your main DataFrame's age_range
    into the short keys used in your infiltration/vent lookup or NTA data.

    Now expanded to include:
      - "1900-2000" => "1900-2000"
      - "2000-2024" => "2000-2024"
      - plus older ones like "<1970", "1970-1992", etc.
    """
    # You can expand as needed.
    mapping = {
        "pre-1970": "<1970",
        "1970 - 1992": "1970-1992",
        "1992 - 2005": "1992-2005",
        "2005 - 2015": "2005-2015",
        "2015 and later": ">2015",
        "1900-2000": "1900-2000",
        "2000-2024": "2000-2024"
    }
    return mapping.get(age_range_str, ">2015")  # fallback => >2015

def map_infiltration_key(building_row):
    """
    Decide infiltration key from building function + sub-type fields.
    Updated to handle e.g. 'two_and_a_half_story_house' for certain residential types,
    or 'meeting_function' for certain non-res types, etc.

    If not recognized, fall back to a perimeter-based logic or default.
    """
    bldg_func = safe_lower(building_row.get("building_function", "residential"))
    if bldg_func == "residential":
        # 1) check if we have a recognized 'residential_type'
        res_type = safe_lower(building_row.get("residential_type", ""))
        if "two-and-a-half-story" in res_type:
            return "two_and_a_half_story_house"
        # Could add more if/elif logic for other residential_type strings:
        # elif "row house" in res_type:
        #     return "row_house"
        #
        # else fallback to perimeter-based approach as in original
        perimeter = building_row.get("perimeter", 40)
        if perimeter > 60:
            return "A_detached"
        else:
            return "A_corner"

    else:
        # Non-res => check 'non_residential_type'
        nonres_type = safe_lower(building_row.get("non_residential_type", ""))
        if "meeting function" in nonres_type:
            return "meeting_function"
        # else fallback
        return "office_multi_top"

def map_usage_key(building_row):
    """
    For non-res ventilation usage flow reference. 
    If building is residential => usage_key => None.
    If it's e.g. 'meeting function' => 'office_area_based' (example).
    """
    bldg_func = safe_lower(building_row.get("building_function", "residential"))
    if bldg_func == "residential":
        return None
    else:
        nonres_type = safe_lower(building_row.get("non_residential_type", ""))
        if "meeting function" in nonres_type:
            return "office_area_based"
        else:
            return "retail"

def map_ventilation_system(building_row):
    """
    Decide system type (A, B, C, or D) from building row.
    As an example: default 'C' for residential, 'D' for non-res.
    """
    bldg_func = safe_lower(building_row.get("building_function", "residential"))
    if bldg_func == "residential":
        return "C"  # default mechanical exhaust for res
    else:
        return "D"  # default balanced w/ HRV for non-res

  --- File Contents End ---

  File: schedules.py
  --- File Contents Start ---
# ventilation/schedules.py

from geomeppy import IDF

def create_always_on_schedule(idf, sched_name="AlwaysOnSched"):
    """
    Creates a SCHEDULE:CONSTANT with a Fraction = 1.0
    for infiltration or ventilation that runs 24/7.
    """
    # Check if already exists
    existing = idf.getobject("SCHEDULE:CONSTANT", sched_name.upper())
    if existing:
        return existing  # No need to recreate

    schedule = idf.newidfobject("SCHEDULE:CONSTANT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"
    schedule.Hourly_Value = 1.0
    return schedule


def create_day_night_schedule(idf, sched_name="VentSched_DayNight"):
    """
    Day/Night schedule that is 0.5 at night, 1.0 during day.
    Example: 06:00-22:00 => 1.0, else => 0.5
    """
    # Check if already exists
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: AllDays"
    schedule.Field_3 = "Until: 06:00,0.5"
    schedule.Field_4 = "Until: 22:00,1.0"
    schedule.Field_5 = "Until: 24:00,0.5"
    return schedule


def create_workhours_schedule(idf, sched_name="WorkHoursSched"):
    """
    Workhours schedule: 
      - 0.2 fraction from midnight to 09:00,
      - 1.0 from 09:00 to 17:00,
      - 0.2 from 17:00 to midnight,
      - weekends/holidays => 0.2 all day
    """
    # Check if already exists
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    schedule = idf.newidfobject("SCHEDULE:COMPACT")
    schedule.Name = sched_name
    schedule.Schedule_Type_Limits_Name = "Fraction"

    schedule.Field_1 = "Through: 12/31"
    schedule.Field_2 = "For: Weekdays"
    schedule.Field_3 = "Until: 09:00,0.2"
    schedule.Field_4 = "Until: 17:00,1.0"
    schedule.Field_5 = "Until: 24:00,0.2"
    schedule.Field_6 = "For: Saturday Sunday Holiday"
    schedule.Field_7 = "Until: 24:00,0.2"
    return schedule


# ------------------------------------------------------------------------
# NEW HELPER FUNCTIONS FOR DYNAMIC SCHEDULES
# ------------------------------------------------------------------------

def create_schedule_from_pattern(idf, sched_name, pattern, schedule_type_limits="Fraction"):
    """
    Creates a SCHEDULE:COMPACT in the IDF from a single pattern of
    (start_hour, end_hour, fraction_value) tuples for ALL days.

    :param idf: geomeppy IDF instance
    :param sched_name: name of the schedule in E+
    :param pattern: list of (start_hour, end_hour, value), e.g. [(0,6,0.5), (6,22,1.0), (22,24,0.5)]
    :param schedule_type_limits: e.g. "Fraction" or "OnOff"
    :returns: the new or existing SCHEDULE:COMPACT object
    """
    # Check if schedule already exists
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    sched_obj = idf.newidfobject("SCHEDULE:COMPACT")
    sched_obj.Name = sched_name
    sched_obj.Schedule_Type_Limits_Name = schedule_type_limits

    # We'll define just one set of rules "Through: 12/31", "For: AllDays"
    # If you want to differentiate weekdays vs. weekends in the same schedule,
    # see create_schedule_from_weekday_weekend_pattern() below.
    field_idx = 1
    sched_obj[f"Field_{field_idx}"] = "Through: 12/31"
    field_idx += 1

    sched_obj[f"Field_{field_idx}"] = "For: AllDays"
    field_idx += 1

    # Now loop over the pattern, building lines like "Until: HH:MM, fraction"
    for (start_hr, end_hr, val) in pattern:
        # E+ SCHEDULE:COMPACT lines are sequential. We just say "Until: end_hr"
        # The fraction applies from previous end_hr to new end_hr.
        # For the first chunk, it starts at midnight implicitly.
        # e.g. "Until: 06:00,0.5"
        line_str = f"Until: {end_hr:02d}:00,{val}"
        sched_obj[f"Field_{field_idx}"] = line_str
        field_idx += 1

    return sched_obj


def create_schedule_from_weekday_weekend_pattern(idf, sched_name, weekday_pattern, weekend_pattern, 
                                                 schedule_type_limits="Fraction"):
    """
    Creates a SCHEDULE:COMPACT with two sets of rules:
    - One for Weekdays
    - One for Saturday Sunday Holiday

    :param idf: geomeppy IDF instance
    :param sched_name: name of the schedule in E+
    :param weekday_pattern: list of (start_hr, end_hr, fraction) for M-F
    :param weekend_pattern: list of (start_hr, end_hr, fraction) for Sat/Sun/Holiday
    :param schedule_type_limits: e.g. "Fraction"
    :returns: new or existing SCHEDULE:COMPACT
    """
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    sched_obj = idf.newidfobject("SCHEDULE:COMPACT")
    sched_obj.Name = sched_name
    sched_obj.Schedule_Type_Limits_Name = schedule_type_limits

    # First chunk: Through: 12/31, For: Weekdays
    field_idx = 1
    sched_obj[f"Field_{field_idx}"] = "Through: 12/31"
    field_idx += 1

    sched_obj[f"Field_{field_idx}"] = "For: Weekdays"
    field_idx += 1

    for (start_hr, end_hr, val) in weekday_pattern:
        line_str = f"Until: {end_hr:02d}:00,{val}"
        sched_obj[f"Field_{field_idx}"] = line_str
        field_idx += 1

    # Next chunk: For Saturday Sunday Holiday
    sched_obj[f"Field_{field_idx}"] = "For: Saturday Sunday Holiday"
    field_idx += 1

    for (start_hr, end_hr, val) in weekend_pattern:
        line_str = f"Until: {end_hr:02d}:00,{val}"
        sched_obj[f"Field_{field_idx}"] = line_str
        field_idx += 1

    return sched_obj


def ensure_dynamic_schedule(idf, sched_name, weekday_pattern=None, weekend_pattern=None):
    """
    A convenience function that:
     - if only weekday_pattern is provided, creates schedule from that pattern for all days;
     - if both weekday & weekend patterns provided, creates a weekday/weekend schedule.

    :param idf: geomeppy IDF
    :param sched_name: string
    :param weekday_pattern: list of (start_hr, end_hr, fraction)
    :param weekend_pattern: list of (start_hr, end_hr, fraction)
    :return: the schedule object
    """
    existing = idf.getobject("SCHEDULE:COMPACT", sched_name.upper())
    if existing:
        return existing

    if weekday_pattern and not weekend_pattern:
        # same pattern for all days
        return create_schedule_from_pattern(idf, sched_name, weekday_pattern)

    elif weekday_pattern and weekend_pattern:
        return create_schedule_from_weekday_weekend_pattern(idf, sched_name, weekday_pattern, weekend_pattern)

    else:
        # fallback => always on
        return create_always_on_schedule(idf, sched_name)

  --- File Contents End ---

  File: ventilation_lookup.py
  --- File Contents Start ---
# ventilation_lookup.py

"""
This file defines a large nested dictionary called `ventilation_lookup`
that organizes infiltration/ventilation parameters by:
  1) scenario ("scenario1" or "scenario2")
  2) calibration stage ("pre_calibration" or "post_calibration")
Inside each stage, you have infiltration ranges, year factors, system controls, etc.

Example usage:
    from ventilation_lookup import ventilation_lookup

    # Suppose we want infiltration info for scenario2, pre_calibration, a "two_and_a_half_story_house"
    infiltration_ranges = ventilation_lookup["scenario2"]["pre_calibration"]["residential_infiltration_range"]
    infiltration_tuple = infiltration_ranges.get("two_and_a_half_story_house", (1.0, 1.2))
    # infiltration_tuple might be something like (1.3, 1.5) if you set it below
"""

ventilation_lookup = {
    # -------------------------------------------------------------------------
    # SCENARIO 1
    # -------------------------------------------------------------------------
    "scenario1": {
        "pre_calibration": {
            # -----------------------------------------------------------
            # 1) Infiltration ranges
            # -----------------------------------------------------------
            "residential_infiltration_range": {
                # Example new sub-type for a residential building
                "two_and_a_half_story_house": (1.1, 1.3),
                "apartment": (0.9, 1.1),
                "row_house": (1.0, 1.2),
            },
            "non_res_infiltration_range": {
                "meeting_function": (0.5, 0.7),
                "office_multi_lower": (0.4, 0.6),
                "office_multi_top": (0.6, 0.8)
            },

            # -----------------------------------------------------------
            # 2) Year-of-construction factor
            # -----------------------------------------------------------
            "year_factor_range": {
                "1900-2000":  (2.0, 2.4),
                "2000-2024":  (1.2, 1.4),
                "<1970":      (2.5, 3.5),
                "1970-1992":  (1.8, 2.2),
                "1992-2005":  (1.4, 1.6),
                "2005-2015":  (1.1, 1.3),
                ">2015":      (0.9, 1.1)
            },

            # -----------------------------------------------------------
            # 3) System control factors
            # -----------------------------------------------------------
            "system_control_range_res": {
                "A": {"f_ctrl_range": (0.9, 1.0)},
                "B": {"f_ctrl_range": (0.50, 0.60)},
                "C": {"f_ctrl_range": (0.80, 0.90)},
                "D": {"f_ctrl_range": (0.95, 1.05)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (0.9, 1.0)},
                "B": {"f_ctrl_range": (0.80, 0.90)},
                "C": {"f_ctrl_range": (0.60, 0.70)},
                "D": {"f_ctrl_range": (0.75, 0.85)}
            },

            # -----------------------------------------------------------
            # 4) Fan pressure, HRV efficiency
            # -----------------------------------------------------------
            "fan_pressure_range": {
                "res_mech": (40, 60),
                "nonres_intake": (90, 110),
                "nonres_exhaust": (140, 160)
            },
            "hrv_sensible_eff_range": (0.7, 0.8)
        },

        "post_calibration": {
            "residential_infiltration_range": {
                "two_and_a_half_story_house": (1.2, 1.2),
                "apartment": (1.0, 1.0),
                "row_house": (1.1, 1.1)
            },
            "non_res_infiltration_range": {
                "meeting_function": (0.6, 0.6),
                "office_multi_lower": (0.5, 0.5),
                "office_multi_top": (0.7, 0.7)
            },

            "year_factor_range": {
                "1900-2000":  (2.2, 2.2),
                "2000-2024":  (1.3, 1.3),
                "<1970":      (3.0, 3.0),
                "1970-1992":  (2.0, 2.0),
                "1992-2005":  (1.5, 1.5),
                "2005-2015":  (1.2, 1.2),
                ">2015":      (1.0, 1.0)
            },

            "system_control_range_res": {
                "A": {"f_ctrl_range": (1.0, 1.0)},
                "B": {"f_ctrl_range": (0.57, 0.57)},
                "C": {"f_ctrl_range": (0.85, 0.85)},
                "D": {"f_ctrl_range": (1.0, 1.0)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (1.0, 1.0)},
                "B": {"f_ctrl_range": (0.85, 0.85)},
                "C": {"f_ctrl_range": (0.65, 0.65)},
                "D": {"f_ctrl_range": (0.8, 0.8)}
            },

            "fan_pressure_range": {
                "res_mech": (50, 50),
                "nonres_intake": (100, 100),
                "nonres_exhaust": (150, 150)
            },
            "hrv_sensible_eff_range": (0.75, 0.75)
        }
    },

    # -------------------------------------------------------------------------
    # SCENARIO 2
    # -------------------------------------------------------------------------
    "scenario2": {
        "pre_calibration": {
            "residential_infiltration_range": {
                # maybe scenario2 has slightly higher infiltration
                "two_and_a_half_story_house": (1.3, 1.5),
                "apartment": (1.0, 1.2),
                "row_house": (1.1, 1.3)
            },
            "non_res_infiltration_range": {
                # or scenario2 meeting_function infiltration a bit bigger
                "meeting_function": (0.6, 0.8),
                "office_multi_lower": (0.4, 0.7),
                "office_multi_top": (0.7, 0.9)
            },

            "year_factor_range": {
                "1900-2000":  (2.1, 2.5),
                "2000-2024":  (1.3, 1.5),
                "<1970":      (2.5, 3.5),
                "1970-1992":  (1.8, 2.2),
                "1992-2005":  (1.4, 1.6),
                "2005-2015":  (1.1, 1.3),
                ">2015":      (0.9, 1.1)
            },

            "system_control_range_res": {
                "A": {"f_ctrl_range": (0.85, 0.95)},
                "B": {"f_ctrl_range": (0.45, 0.55)},
                "C": {"f_ctrl_range": (0.70, 0.80)},
                "D": {"f_ctrl_range": (0.90, 1.00)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (0.85, 0.95)},
                "B": {"f_ctrl_range": (0.75, 0.85)},
                "C": {"f_ctrl_range": (0.55, 0.65)},
                "D": {"f_ctrl_range": (0.70, 0.80)}
            },

            "fan_pressure_range": {
                "res_mech": (45, 65),
                "nonres_intake": (95, 115),
                "nonres_exhaust": (145, 165)
            },
            "hrv_sensible_eff_range": (0.65, 0.75)
        },

        "post_calibration": {
            "residential_infiltration_range": {
                "two_and_a_half_story_house": (1.4, 1.4),
                "apartment": (1.1, 1.1),
                "row_house": (1.2, 1.2)
            },
            "non_res_infiltration_range": {
                "meeting_function": (0.7, 0.7),
                "office_multi_lower": (0.6, 0.6),
                "office_multi_top": (0.75, 0.75)
            },

            "year_factor_range": {
                "1900-2000":  (2.3, 2.3),
                "2000-2024":  (1.4, 1.4),
                "<1970":      (3.2, 3.2),
                "1970-1992":  (2.2, 2.2),
                "1992-2005":  (1.6, 1.6),
                "2005-2015":  (1.3, 1.3),
                ">2015":      (1.0, 1.0)
            },

            "system_control_range_res": {
                "A": {"f_ctrl_range": (1.0, 1.0)},
                "B": {"f_ctrl_range": (0.60, 0.60)},
                "C": {"f_ctrl_range": (0.80, 0.80)},
                "D": {"f_ctrl_range": (0.95, 0.95)}
            },
            "system_control_range_nonres": {
                "A": {"f_ctrl_range": (1.0, 1.0)},
                "B": {"f_ctrl_range": (0.80, 0.80)},
                "C": {"f_ctrl_range": (0.60, 0.60)},
                "D": {"f_ctrl_range": (0.75, 0.75)}
            },

            "fan_pressure_range": {
                "res_mech": (55, 55),
                "nonres_intake": (105, 105),
                "nonres_exhaust": (155, 155)
            },
            "hrv_sensible_eff_range": (0.70, 0.70)
        }
    }
}

  --- File Contents End ---

  File: ventilation_overrides_from_excel.py
  --- File Contents Start ---
# ventilation/ventilation_overrides_from_excel.py

import pandas as pd
import copy
import math

def read_ventilation_overrides_from_excel(excel_path):
    """
    Reads an Excel file with columns:
        - calibration_stage
        - main_key
        - sub_key
        - param_name
        - min_val
        - max_val
        - fixed_value

    Returns a nested dict: override_data[stage][main_key][sub_key][param_name] = ...
    
    Where the "..." can be:
      - a tuple (min, max) if numeric
      - a single string or numeric if 'fixed_value' is provided and is non-NaN
        (we store it as (val, val) if numeric, or keep as a plain string if textual).
    
    This can override infiltration ranges, year_factor ranges, OR new schedule info.
    For schedule overrides, 'main_key' might be "schedule_info",
    sub_key might be e.g. "residential", param_name might be "default_infiltration_schedule",
    and fixed_value could be e.g. "InfilResSched".

    Example row:
        calibration_stage = "pre_calibration"
        main_key          = "schedule_info"
        sub_key           = "residential"
        param_name        = "default_infiltration_schedule"
        min_val           = NaN
        max_val           = NaN
        fixed_value       = "MyInfilResSched"

    The resulting override_data will have:
        override_data["pre_calibration"]["schedule_info"]["residential"]["default_infiltration_schedule"] = "MyInfilResSched"
    """
    df = pd.read_excel(excel_path)

    required_cols = ["calibration_stage","main_key","sub_key","param_name","min_val","max_val","fixed_value"]
    for c in required_cols:
        if c not in df.columns:
            raise ValueError(f"Missing column '{c}' in {excel_path}")

    override_data = {}

    for _, row in df.iterrows():
        stage = str(row["calibration_stage"]).strip()
        mkey  = str(row["main_key"]).strip()       # e.g. "residential_infiltration_range" or "schedule_info"
        skey  = str(row["sub_key"]).strip()        # e.g. "A_corner" or "residential" or ""
        pname = str(row["param_name"]).strip()     # e.g. "f_ctrl_range", "default_infiltration_schedule", or ""

        fv = row["fixed_value"]  # could be numeric or string
        mn = row["min_val"]      # typically numeric or NaN
        mx = row["max_val"]      # typically numeric or NaN

        if stage not in override_data:
            override_data[stage] = {}
        if mkey not in override_data[stage]:
            override_data[stage][mkey] = {}

        # Decide how to store
        # 1) If fixed_value is not NaN => store that
        #    - If it's purely numeric, we store as (fv,fv) for consistency with min,max range
        #    - If it's a string, we'll store it as a plain string override
        # 2) Else if min_val and max_val are numeric => store as (min_val,max_val)
        # 3) Otherwise skip if all are NaN

        # Helper to test if something is numeric
        def is_number(x):
            try:
                float(x)
                return True
            except (ValueError, TypeError):
                return False

        if pd.notna(fv):
            # If the fixed_value is numeric => store as a numeric tuple (fv,fv)
            if is_number(fv):
                val_tuple = (float(fv), float(fv))
                final_value = val_tuple
            else:
                # It's likely a string => store it directly as that string
                final_value = str(fv).strip()
        elif pd.notna(mn) and pd.notna(mx) and is_number(mn) and is_number(mx):
            val_tuple = (float(mn), float(mx))
            final_value = val_tuple
        else:
            # skip if no valid data
            continue

        # Insert into override_data
        # Cases:
        #    (a) skey == "" and pname == "" => override_data[stage][mkey] = final_value
        #    (b) skey != "" and pname == "" => override_data[stage][mkey][skey] = final_value
        #    (c) skey + pname => override_data[stage][mkey][skey][pname] = final_value
        if skey == "" and pname == "":
            override_data[stage][mkey] = final_value
        elif skey != "" and pname == "":
            if not isinstance(override_data[stage][mkey], dict):
                override_data[stage][mkey] = {}
            override_data[stage][mkey][skey] = final_value
        else:
            # if we have a param_name => store in stage[mkey][skey][pname]
            if skey not in override_data[stage][mkey] or not isinstance(override_data[stage][mkey][skey], dict):
                override_data[stage][mkey][skey] = {}
            override_data[stage][mkey][skey][pname] = final_value

    return override_data


def apply_ventilation_overrides_to_lookup(default_lookup, override_data):
    """
    Merges override_data into default_lookup (similar to ventilation_lookup).
    
    override_data structure:
      override_data[stage][main_key][sub_key][param_name] = final_value
        (final_value can be a tuple (min,max), or a string for schedules)

    For each stage in override_data:
      - If stage doesn't exist in default_lookup, we create it.
      - For each main_key in override_data => if it's a tuple or string, override
        directly. If it's a dict => merge deeper.
    
    Example usage:
      new_lookup = apply_ventilation_overrides_to_lookup(ventilation_lookup, override_data)
    """
    # If you prefer not to mutate default_lookup in place, do a copy
    new_lookup = copy.deepcopy(default_lookup)

    for stage, stage_dict in override_data.items():
        if stage not in new_lookup:
            new_lookup[stage] = {}

        for mkey, val_mkey in stage_dict.items():
            # val_mkey might be:
            #   - a numeric tuple or string => direct override
            #   - a dict => deeper merges (subkeys, param_names)

            if not isinstance(val_mkey, dict):
                # So if it's a tuple or a string => direct override
                new_lookup[stage][mkey] = val_mkey
                continue

            # if it's a dict => we merge it
            if mkey not in new_lookup[stage]:
                new_lookup[stage][mkey] = {}

            for subk, subv in val_mkey.items():
                # subv might be a tuple, string, or another dict
                if not isinstance(subv, dict):
                    # direct override
                    new_lookup[stage][mkey][subk] = subv
                else:
                    # deeper dict => e.g. {param_name: (min,max) or string}
                    if subk not in new_lookup[stage][mkey]:
                        new_lookup[stage][mkey][subk] = {}
                    for param_key, param_val in subv.items():
                        # param_val could be tuple or string
                        new_lookup[stage][mkey][subk][param_key] = param_val

    return new_lookup

  --- File Contents End ---

================================================================================

Folder: D:\Documents\E_Plus_2030_py\ventilation\__pycache__

================================================================================

